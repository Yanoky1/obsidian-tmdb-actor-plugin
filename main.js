/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// i18n.ts
var i18n_exports = {};
__export(i18n_exports, {
  getCurrentLanguage: () => getCurrentLanguage,
  getSupportedLanguages: () => getSupportedLanguages,
  initializeLanguage: () => initializeLanguage,
  setLanguage: () => setLanguage,
  t: () => t,
  tWithParams: () => tWithParams
});
function initializeLanguage(lang) {
  if (!lang || lang !== "ru" && lang !== "en") {
    const browserLang = navigator.language.split("-")[0];
    currentLanguage = browserLang === "ru" || browserLang === "en" ? browserLang : "en";
  } else {
    currentLanguage = lang;
  }
  console.log(`[i18n] Language initialized: ${currentLanguage}`);
}
function setLanguage(language) {
  currentLanguage = language;
}
function getCurrentLanguage() {
  return currentLanguage;
}
function getSupportedLanguages() {
  return [
    { code: "ru", name: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439" },
    { code: "en", name: "English" }
  ];
}
function t(key) {
  const keys = key.split(".");
  let value = translations[currentLanguage];
  for (const k of keys) {
    if (value && typeof value === "object" && k in value) {
      value = value[k];
    } else {
      console.warn(`Translation key not found: ${key}`);
      return key;
    }
  }
  return typeof value === "string" ? value : key;
}
function tWithParams(key, params) {
  let translation = t(key);
  for (const [paramKey, paramValue] of Object.entries(params)) {
    translation = translation.replace(
      new RegExp(`\\{${paramKey}\\}`, "g"),
      String(paramValue)
    );
  }
  return translation;
}
var ru, en, translations, currentLanguage;
var init_i18n = __esm({
  "i18n.ts"() {
    ru = {
      common: {
        ok: "\u041E\u041A",
        cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
        save: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C",
        loading: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430...",
        error: "\u041E\u0448\u0438\u0431\u043A\u0430",
        success: "\u0423\u0441\u043F\u0435\u0448\u043D\u043E",
        type: "\u0422\u0438\u043F",
        status: "\u0421\u0442\u0430\u0442\u0443\u0441"
      },
      modals: {
        searchTitle: "\u{1F37F} \u041F\u043E\u0438\u0441\u043A \u0444\u0438\u043B\u044C\u043C\u0430 \u0438\u043B\u0438 \u0441\u0435\u0440\u0438\u0430\u043B\u0430",
        searchPlaceholder: "\u041F\u043E\u0438\u0441\u043A \u043F\u043E \u043A\u043B\u044E\u0447\u0435\u0432\u043E\u043C\u0443 \u0441\u043B\u043E\u0432\u0443",
        searchButton: "\u041D\u0430\u0439\u0442\u0438",
        searching: "\u041F\u043E\u0438\u0441\u043A...",
        enterMovieName: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0444\u0438\u043B\u044C\u043C\u0430 \u0438\u043B\u0438 \u0441\u0435\u0440\u0438\u0430\u043B\u0430 \u0434\u043B\u044F \u043F\u043E\u0438\u0441\u043A\u0430",
        needApiToken: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C API \u0442\u043E\u043A\u0435\u043D \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
        loadingMovieInfo: "\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u0442\u0441\u044F \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0444\u0438\u043B\u044C\u043C\u0435...",
        preparingImages: "\u041F\u043E\u0434\u0433\u043E\u0442\u043E\u0432\u043A\u0430 \u043A \u0441\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u044E \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439...",
        movieInfoLoaded: "\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0444\u0438\u043B\u044C\u043C\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u0430!",
        errorMovieData: "\u041E\u0448\u0438\u0431\u043A\u0430: \u043D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435 \u0444\u0438\u043B\u044C\u043C\u0430",
        errorUnexpected: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430",
        errorGettingDetails: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0438 \u043E \u0444\u0438\u043B\u044C\u043C\u0435",
        posterPlaceholderEmoji: "\u{1F4FD}\uFE0F",
        posterTooltipGeoblock: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0433\u0435\u043E\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u043A\u0430)",
        posterTooltipMissing: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442",
        posterTooltipEmptyLink: "\u041F\u0443\u0441\u0442\u0430\u044F \u0441\u0441\u044B\u043B\u043A\u0430 \u043D\u0430 \u043F\u043E\u0441\u0442\u0435\u0440",
        posterTooltipInvalidLink: "\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u0430\u044F \u0441\u0441\u044B\u043B\u043A\u0430 \u043D\u0430 \u043F\u043E\u0441\u0442\u0435\u0440",
        selectImagesToDownload: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0434\u043B\u044F \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438",
        selectImagesDesc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435, \u043A\u0430\u043A\u0438\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432\u044B \u0445\u043E\u0442\u0438\u0442\u0435 \u0441\u043A\u0430\u0447\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E. \u041D\u0435\u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0431\u0443\u0434\u0443\u0442 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u0432\u0435\u0431-\u0441\u0441\u044B\u043B\u043A\u0438.",
        posterImage: "\u041F\u043E\u0441\u0442\u0435\u0440",
        coverImage: "\u041E\u0431\u043B\u043E\u0436\u043A\u0430/\u0424\u043E\u043D",
        logoImage: "\u041B\u043E\u0433\u043E\u0442\u0438\u043F",
        selectImages: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0434\u043B\u044F \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438:",
        imageAvailable: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E \u0434\u043B\u044F \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438",
        imageNotAvailable: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E",
        imageNotAvailableDesc: "\u042D\u0442\u043E \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E \u0438\u0437 API",
        imageUnavailable: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E",
        downloadPoster: "\u0421\u043A\u0430\u0447\u0430\u0442\u044C \u043F\u043E\u0441\u0442\u0435\u0440",
        downloadCover: "\u0421\u043A\u0430\u0447\u0430\u0442\u044C \u043E\u0431\u043B\u043E\u0436\u043A\u0443",
        downloadLogo: "\u0421\u043A\u0430\u0447\u0430\u0442\u044C \u043B\u043E\u0433\u043E\u0442\u0438\u043F",
        cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
        continue: "\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C",
        // Image Approval Modal
        approveImage: "\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435",
        approveImageDesc: "\u0412\u0430\u043C \u043D\u0440\u0430\u0432\u0438\u0442\u0441\u044F \u044D\u0442\u043E \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435?",
        selectAlternativeDesc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435, \u043A\u043E\u0442\u043E\u0440\u043E\u0435 \u0432\u0430\u043C \u043D\u0440\u0430\u0432\u0438\u0442\u0441\u044F, \u0438\u0437 \u0430\u043B\u044C\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432",
        previousImage: "\u041F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0435\u0435",
        nextImage: "\u0421\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0435",
        showAlternatives: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0430\u043B\u044C\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432\u044B",
        skip: "\u041F\u0440\u043E\u043F\u0443\u0441\u0442\u0438\u0442\u044C",
        approve: "\u041E\u0434\u043E\u0431\u0440\u0438\u0442\u044C",
        selectThis: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u044D\u0442\u043E",
        loadingAlternativeImages: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430 \u0430\u043B\u044C\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432\u043D\u044B\u0445 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439..."
      },
      suggesters: {
        fileListError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0441\u043F\u0438\u0441\u043A\u0430 \u0444\u0430\u0439\u043B\u043E\u0432:",
        folderListError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0441\u043F\u0438\u0441\u043A\u0430 \u043F\u0430\u043F\u043E\u043A:"
      },
      validation: {
        invalidApiToken: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D",
        invalidSearchQuery: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441",
        invalidMovieId: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 ID \u0444\u0438\u043B\u044C\u043C\u0430",
        invalidPaginationParams: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0435 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u044B \u043F\u0430\u0433\u0438\u043D\u0430\u0446\u0438\u0438"
      },
      provider: {
        tokenRequired: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
        enterMovieTitle: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0444\u0438\u043B\u044C\u043C\u0430 \u0438\u043B\u0438 \u0441\u0435\u0440\u0438\u0430\u043B\u0430 \u0434\u043B\u044F \u043F\u043E\u0438\u0441\u043A\u0430",
        nothingFound: '\u041F\u043E \u0437\u0430\u043F\u0440\u043E\u0441\u0443 "{query}" \u043D\u0438\u0447\u0435\u0433\u043E \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E.',
        invalidMovieId: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ID \u0444\u0438\u043B\u044C\u043C\u0430",
        tokenRequiredForMovie: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D",
        movieInfoError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044E \u043E \u0444\u0438\u043B\u044C\u043C\u0435",
        tryChangeQuery: "\u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0438\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441."
      },
      errorHandler: {
        badRequest: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u0432\u0432\u0435\u0434\u0435\u043D\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435.",
        unauthorized: "\u041D\u0435\u0430\u0432\u0442\u043E\u0440\u0438\u0437\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0434\u043E\u0441\u0442\u0443\u043F. \u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044C, \u0447\u0442\u043E API \u0442\u043E\u043A\u0435\u043D \u0443\u043A\u0430\u0437\u0430\u043D \u0438 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D.",
        forbidden: "\u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D \u0441\u0443\u0442\u043E\u0447\u043D\u044B\u0439 \u043B\u0438\u043C\u0438\u0442. \u041F\u043E\u0434\u043E\u0436\u0434\u0438\u0442\u0435 \u0438 \u043F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0441\u043D\u043E\u0432\u0430.",
        notFound: "\u0414\u0430\u043D\u043D\u044B\u0435 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0438\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441.",
        tooManyRequests: "\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u043D\u043E\u0433\u043E \u0437\u0430\u043F\u0440\u043E\u0441\u043E\u0432. \u041F\u043E\u0434\u043E\u0436\u0434\u0438\u0442\u0435 \u043D\u0435\u043C\u043D\u043E\u0433\u043E \u0438 \u043F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0441\u043D\u043E\u0432\u0430.",
        internalServerError: "\u0412\u043D\u0443\u0442\u0440\u0435\u043D\u043D\u044F\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u041A\u0438\u043D\u043E\u043F\u043E\u0438\u0441\u043A\u0430. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
        badGateway: "\u0421\u0435\u0440\u0432\u0435\u0440 \u041A\u0438\u043D\u043E\u043F\u043E\u0438\u0441\u043A\u0430 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (502 Bad Gateway).",
        serviceUnavailable: "\u0421\u0435\u0440\u0432\u0438\u0441 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D. \u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u043E\u043F\u044B\u0442\u043A\u0443 \u043F\u043E\u0437\u0436\u0435.",
        gatewayTimeout: "\u0421\u0435\u0440\u0432\u0435\u0440 \u043D\u0435 \u043E\u0442\u0432\u0435\u0447\u0430\u0435\u0442. \u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D\u043E \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F (504 Gateway Timeout).",
        networkError: "\u041F\u0440\u043E\u0431\u043B\u0435\u043C\u044B \u0441 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435\u043C \u043A \u0438\u043D\u0442\u0435\u0440\u043D\u0435\u0442\u0443. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u0435.",
        unknownStatusError: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0435 \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443 (\u043A\u043E\u0434 {status}). \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
        unexpectedError: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0435. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435."
      },
      images: {
        poster: "\u043F\u043E\u0441\u0442\u0435\u0440\u0430",
        cover: "\u043E\u0431\u043B\u043E\u0436\u043A\u0438",
        logo: "\u043B\u043E\u0433\u043E\u0442\u0438\u043F\u0430",
        noImagesToDownload: "\u041D\u0435\u0442 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439 \u0434\u043B\u044F \u0441\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u044F",
        downloading: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435",
        downloadingPoster: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435 \u043F\u043E\u0441\u0442\u0435\u0440\u0430...",
        downloadingCover: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435 \u043E\u0431\u043B\u043E\u0436\u043A\u0438...",
        downloadingLogo: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435 \u043B\u043E\u0433\u043E\u0442\u0438\u043F\u0430...",
        completed: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E!",
        completedAllDownloaded: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0412\u0441\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0441\u043A\u0430\u0447\u0430\u043D\u044B",
        completedAlreadyLocal: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0443\u0436\u0435 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u044B\u0435",
        completedWithErrors: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0423\u0441\u043F\u0435\u0448\u043D\u043E: {successful}, \u043D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C: {failed}",
        invalidUrl: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 URL: {url}. \u041E\u0436\u0438\u0434\u0430\u043B\u0441\u044F \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 HTTP/HTTPS URL.",
        imageNotFound: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E (404): {url}",
        accessForbidden: "\u0414\u043E\u0441\u0442\u0443\u043F \u0437\u0430\u043F\u0440\u0435\u0449\u0435\u043D (403): {url}",
        serverError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 ({status}): {url}",
        httpError: "HTTP {status}: {url}",
        downloadFailed: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043A\u0430\u0447\u0430\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435: {url}",
        timeout: "\u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D\u043E \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F \u043F\u043E\u0441\u043B\u0435 {timeout}\u043C\u0441",
        downloadedWithErrors: "\u0421\u043A\u0430\u0447\u0430\u043D\u043E: {successful}/{total} \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439. \u041D\u0435\u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435.",
        imagesUnavailable: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435. \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u044E\u0442\u0441\u044F \u043E\u0440\u0438\u0433\u0438\u043D\u0430\u043B\u044C\u043D\u044B\u0435 \u0441\u0441\u044B\u043B\u043A\u0438.",
        processingError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439",
        posterUnavailable: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
        coverUnavailable: "\u041E\u0431\u043B\u043E\u0436\u043A\u0430 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430 (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D\u0430 \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
        logoUnavailable: "\u041B\u043E\u0433\u043E\u0442\u0438\u043F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
        downloadError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043A\u0430\u0447\u0430\u0442\u044C"
      },
      utils: {
        unknownMovie: "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u044B\u0439 \u0444\u0438\u043B\u044C\u043C",
        copyPrefix: "\u041A\u043E\u043F\u0438\u044F",
        templateNotFound: "\u0428\u0430\u0431\u043B\u043E\u043D \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D",
        templateReadError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u0440\u043E\u0447\u0438\u0442\u0430\u0442\u044C \u0444\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430"
      },
      settings: {
        apiToken: "API \u0422\u043E\u043A\u0435\u043D",
        apiTokenDesc: "\u0412\u0430\u043C \u043D\u0443\u0436\u043D\u043E \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C API \u0442\u043E\u043A\u0435\u043D \u0434\u043B\u044F \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u044D\u0442\u043E\u0433\u043E \u043F\u043B\u0430\u0433\u0438\u043D\u0430. \u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0431\u0435\u0441\u043F\u043B\u0430\u0442\u043D\u044B\u0439 \u043F\u043B\u0430\u043D \u0438 \u0441\u043B\u0435\u0434\u0443\u0439\u0442\u0435 \u0438\u043D\u0441\u0442\u0440\u0443\u043A\u0446\u0438\u044F\u043C.",
        getApiToken: "\u041F\u043E\u043B\u0443\u0447\u0438\u0442\u044C API \u0422\u043E\u043A\u0435\u043D",
        checkToken: "\u041F\u0440\u043E\u0432\u0435\u0440\u0438\u0442\u044C \u0442\u043E\u043A\u0435\u043D",
        checking: "\u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C...",
        tokenValid: "\u2705 \u0422\u043E\u043A\u0435\u043D \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D!",
        tokenInvalid: "\u274C \u0422\u043E\u043A\u0435\u043D \u043D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0442\u043E\u043A\u0435\u043D\u0430.",
        tokenError: "\u274C \u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0435 \u0442\u043E\u043A\u0435\u043D\u0430. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
        enterToken: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 API \u0442\u043E\u043A\u0435\u043D \u0434\u043B\u044F \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0438",
        imagesHeading: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F",
        saveImagesLocally: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E",
        saveImagesLocallyDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u0443\u044E \u043F\u0430\u043F\u043A\u0443 \u0432\u043C\u0435\u0441\u0442\u043E \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u0432\u0435\u0431-\u0441\u0441\u044B\u043B\u043E\u043A.",
        imagesFolder: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439",
        imagesFolderDesc: "\u041F\u0430\u043F\u043A\u0430, \u0433\u0434\u0435 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B \u0441\u043A\u0430\u0447\u0430\u043D\u043D\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F.",
        imagesFolderPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: attachments/TMDB",
        savePosterImage: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043F\u043E\u0441\u0442\u0435\u0440\u044B",
        savePosterImageDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043F\u043E\u0441\u0442\u0435\u0440\u044B \u0444\u0438\u043B\u044C\u043C\u043E\u0432/\u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
        saveCoverImage: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043E\u0431\u043B\u043E\u0436\u043A\u0438",
        saveCoverImageDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043E\u0431\u043B\u043E\u0436\u043A\u0438/\u0431\u044D\u043A\u0434\u0440\u043E\u043F\u044B \u0444\u0438\u043B\u044C\u043C\u043E\u0432/\u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
        saveLogoImage: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043B\u043E\u0433\u043E\u0442\u0438\u043F\u044B",
        saveLogoImageDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043B\u043E\u0433\u043E\u0442\u0438\u043F\u044B \u0444\u0438\u043B\u044C\u043C\u043E\u0432/\u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
        moviesHeading: "\u0424\u0438\u043B\u044C\u043C\u044B",
        movieFileName: "\u0418\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0444\u0438\u043B\u044C\u043C\u0430",
        movieFileNameDesc: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0434\u043B\u044F \u0444\u0438\u043B\u044C\u043C\u043E\u0432.",
        movieFileNamePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: {{nameForFile}} ({{year}})",
        movieFileLocation: "\u0420\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u043E\u0432 \u0444\u0438\u043B\u044C\u043C\u043E\u0432",
        movieFileLocationDesc: "\u041D\u043E\u0432\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E \u0444\u0438\u043B\u044C\u043C\u0430\u0445 \u0431\u0443\u0434\u0443\u0442 \u0440\u0430\u0437\u043C\u0435\u0449\u0435\u043D\u044B \u0437\u0434\u0435\u0441\u044C.",
        movieFileLocationPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: \u043F\u0430\u043F\u043A\u04301/\u043F\u0430\u043F\u043A\u04302",
        movieTemplateFile: "\u0424\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430 \u0434\u043B\u044F \u0444\u0438\u043B\u044C\u043C\u043E\u0432",
        movieTemplateFileDesc: "\u0424\u0430\u0439\u043B\u044B \u0431\u0443\u0434\u0443\u0442 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u043A\u0430\u043A \u0448\u0430\u0431\u043B\u043E\u043D\u044B.",
        movieTemplateFilePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: templates/template-file",
        exampleTemplate: "\u041F\u0440\u0438\u043C\u0435\u0440 \u0448\u0430\u0431\u043B\u043E\u043D\u0430",
        seriesHeading: "\u0421\u0435\u0440\u0438\u0430\u043B\u044B",
        seriesFileName: "\u0418\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0441\u0435\u0440\u0438\u0430\u043B\u0430",
        seriesFileNameDesc: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0434\u043B\u044F \u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
        seriesFileNamePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: {{nameForFile}} ({{year}})",
        seriesFileLocation: "\u0420\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u043E\u0432 \u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432",
        seriesFileLocationDesc: "\u041D\u043E\u0432\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E \u0441\u0435\u0440\u0438\u0430\u043B\u0430\u0445 \u0431\u0443\u0434\u0443\u0442 \u0440\u0430\u0437\u043C\u0435\u0449\u0435\u043D\u044B \u0437\u0434\u0435\u0441\u044C.",
        seriesFileLocationPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: \u043F\u0430\u043F\u043A\u04301/\u043F\u0430\u043F\u043A\u04302",
        seriesTemplateFile: "\u0424\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430 \u0434\u043B\u044F \u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432",
        seriesTemplateFileDesc: "\u0424\u0430\u0439\u043B\u044B \u0431\u0443\u0434\u0443\u0442 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u043A\u0430\u043A \u0448\u0430\u0431\u043B\u043E\u043D\u044B.",
        seriesTemplateFilePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: templates/template-file",
        actorHeading: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0430\u043A\u0442\u0435\u0440\u043E\u0432",
        language: "\u042F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430",
        languageDesc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u044F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430 \u043F\u043B\u0430\u0433\u0438\u043D\u0430.",
        // Mobile settings
        mobileSettings: "\u041C\u043E\u0431\u0438\u043B\u044C\u043D\u044B\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
        mobileCoverHeightMultiplier: "\u041C\u043D\u043E\u0436\u0438\u0442\u0435\u043B\u044C \u0432\u044B\u0441\u043E\u0442\u044B \u043E\u0431\u043B\u043E\u0436\u043A\u0438",
        mobileCoverHeightMultiplierDesc: "\u041C\u043D\u043E\u0436\u0438\u0442\u0435\u043B\u044C \u0432\u044B\u0441\u043E\u0442\u044B \u043E\u0431\u043B\u043E\u0436\u043A\u0438 \u0434\u043B\u044F \u043C\u043E\u0431\u0438\u043B\u044C\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432 (\u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E: 1.5)",
        actorFolder: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0430\u043A\u0442\u0451\u0440\u043E\u0432",
        actorFolderDesc: "\u041F\u0430\u043F\u043A\u0430, \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C\u0441\u044F \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E\u0431 \u0430\u043A\u0442\u0451\u0440\u0430\u0445",
        actorTemplate: "\u0424\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430 \u0434\u043B\u044F \u0430\u043A\u0442\u0451\u0440\u043E\u0432",
        actorTemplateDesc: "\u0428\u0430\u0431\u043B\u043E\u043D, \u043A\u043E\u0442\u043E\u0440\u044B\u0439 \u0431\u0443\u0434\u0435\u0442 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u0434\u043B\u044F \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u044F \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u043E\u0431 \u0430\u043A\u0442\u0451\u0440\u0430\u0445",
        actorFileNameFormat: "\u0424\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0430\u043A\u0442\u0451\u0440\u0430",
        actorFileNameFormatDesc: "\u0424\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0434\u043B\u044F \u0430\u043A\u0442\u0451\u0440\u043E\u0432. \u0414\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0435 \u043F\u0435\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0435: {{id}}, {{nameForFile}}",
        validateToken: "\u041F\u0440\u043E\u0432\u0435\u0440\u0438\u0442\u044C \u0442\u043E\u043A\u0435\u043D"
      },
      status: {
        selectStatus: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0441\u0442\u0430\u0442\u0443\u0441:",
        willWatch: "\u0411\u0443\u0434\u0443 \u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C",
        haveWatched: "\u041F\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u043B",
        watching: "\u0421\u043C\u043E\u0442\u0440\u044E",
        dropped: "\u0417\u0430\u0431\u0440\u043E\u0441\u0438\u043B",
        skip: "\u041F\u0440\u043E\u043F\u0443\u0441\u0442\u0438\u0442\u044C",
        useDefault: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u0441\u0442\u0430\u0442\u0443\u0441 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
        defaultStatus: "\u0411\u0443\u0434\u0443 \u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C"
      },
      ratings: {
        myRating: "\u041C\u043E\u044F\u041E\u0446\u0435\u043D\u043A\u0430",
        kinopoiskRating: "\u041A\u0438\u043D\u043E\u043F\u043E\u0438\u0441\u043A\u041E\u0446\u0435\u043D\u043A\u0430",
        year: "\u0413\u043E\u0434"
      }
    };
    en = {
      common: {
        ok: "OK",
        cancel: "Cancel",
        save: "Save",
        loading: "Loading...",
        error: "Error",
        success: "Success",
        type: "Type",
        status: "Status"
      },
      modals: {
        searchTitle: "\u{1F37F} Search movie or TV show",
        searchPlaceholder: "Search by keyword",
        searchButton: "Search",
        searching: "Searching...",
        enterMovieName: "Enter movie or TV show name to search",
        needApiToken: "API token must be specified in plugin settings",
        loadingMovieInfo: "Loading movie information...",
        preparingImages: "Preparing to download images...",
        movieInfoLoaded: "Movie information loaded!",
        errorMovieData: "Error: invalid movie data",
        errorUnexpected: "An unexpected error occurred",
        errorGettingDetails: "An unexpected error occurred while getting movie information",
        posterPlaceholderEmoji: "\u{1F4FD}\uFE0F",
        posterTooltipGeoblock: "Poster unavailable (possibly geo-blocked)",
        posterTooltipMissing: "Poster missing",
        posterTooltipEmptyLink: "Empty poster link",
        posterTooltipInvalidLink: "Invalid poster link",
        selectImagesToDownload: "Select Images to Download",
        selectImagesDesc: "Choose which images you want to download and save locally. Unselected images will use web links.",
        posterImage: "Poster",
        coverImage: "Cover/Backdrop",
        logoImage: "Logo",
        selectImages: "Select images to download:",
        imageAvailable: "Image is available for download",
        imageNotAvailable: "Image not available",
        imageNotAvailableDesc: "This image is not available from the API",
        imageUnavailable: "Image unavailable",
        downloadPoster: "Download Poster",
        downloadCover: "Download Cover",
        downloadLogo: "Download Logo",
        cancel: "Cancel",
        continue: "Continue",
        // Image Approval Modal
        approveImage: "Approve image",
        approveImageDesc: "Do you like this image?",
        selectAlternativeDesc: "Select the image you like from the alternatives",
        previousImage: "Previous",
        nextImage: "Next",
        showAlternatives: "Show alternatives",
        skip: "Skip",
        approve: "Approve",
        selectThis: "Select this",
        loadingAlternativeImages: "Loading alternative images..."
      },
      suggesters: {
        fileListError: "Error getting file list:",
        folderListError: "Error getting folder list:"
      },
      validation: {
        invalidApiToken: "Invalid API token",
        invalidSearchQuery: "Invalid search query",
        invalidMovieId: "Invalid movie ID",
        invalidPaginationParams: "Invalid pagination parameters"
      },
      provider: {
        tokenRequired: "Valid API token must be specified in plugin settings",
        enterMovieTitle: "Enter movie or TV show title to search",
        nothingFound: 'Nothing found for query "{query}".',
        invalidMovieId: "Invalid movie ID",
        tokenRequiredForMovie: "Valid API token must be specified",
        movieInfoError: "Failed to get movie information",
        tryChangeQuery: "Try changing the search query."
      },
      errorHandler: {
        badRequest: "Bad request. Please check the entered data.",
        unauthorized: "Unauthorized access. Make sure the API token is specified and valid.",
        forbidden: "Daily limit exceeded. Please wait and try again.",
        notFound: "Data not found. Try changing the search query.",
        tooManyRequests: "Too many requests. Please wait a bit and try again.",
        internalServerError: "TMDB server internal error. Try again later.",
        badGateway: "TMDB server temporarily unavailable (502 Bad Gateway).",
        serviceUnavailable: "Service temporarily unavailable. Try again later.",
        gatewayTimeout: "Server not responding. Timeout exceeded (504 Gateway Timeout).",
        networkError: "Internet connection problems. Check your connection.",
        unknownStatusError: "An error occurred when requesting the server (code {status}). Try again later.",
        unexpectedError: "An unexpected error occurred during the request. Try again later."
      },
      images: {
        poster: "poster",
        cover: "cover",
        logo: "logo",
        noImagesToDownload: "No images to download",
        downloading: "Downloading",
        downloadingPoster: "Downloading poster...",
        downloadingCover: "Downloading cover...",
        downloadingLogo: "Downloading logo...",
        completed: "Completed!",
        completedAllDownloaded: "Completed! All images downloaded",
        completedAlreadyLocal: "Completed! Images are already local",
        completedWithErrors: "Completed! Successful: {successful}, failed: {failed}",
        invalidUrl: "Invalid URL format: {url}. Expected valid HTTP/HTTPS URL.",
        imageNotFound: "Image not found (404): {url}",
        accessForbidden: "Access forbidden (403): {url}",
        serverError: "Server error ({status}): {url}",
        httpError: "HTTP {status}: {url}",
        downloadFailed: "Failed to download image: {url}",
        timeout: "Timeout after {timeout}ms",
        downloadedWithErrors: "Downloaded: {successful}/{total} images. Some are unavailable in your region.",
        imagesUnavailable: "Images are unavailable in your region. Using original links.",
        processingError: "Error processing images",
        posterUnavailable: "Poster unavailable (possibly blocked in your region)",
        coverUnavailable: "Cover unavailable (possibly blocked in your region)",
        logoUnavailable: "Logo unavailable (possibly blocked in your region)",
        downloadError: "Failed to download"
      },
      utils: {
        unknownMovie: "Unknown Movie",
        copyPrefix: "Copy",
        templateNotFound: "Template not found",
        templateReadError: "Failed to read template file"
      },
      settings: {
        apiToken: "API Token",
        apiTokenDesc: "You need to get API token to use this plugin. Choose free plan and follow steps.",
        getApiToken: "Get API Token",
        checkToken: "Check Token",
        checking: "Checking...",
        tokenValid: "\u2705 Token is valid!",
        tokenInvalid: "\u274C Token is invalid. Please check your token.",
        tokenError: "\u274C Error checking token. Please try again later.",
        enterToken: "Enter API token to check",
        imagesHeading: "Images",
        saveImagesLocally: "Save images locally",
        saveImagesLocallyDesc: "Download and save images to local folder instead of using web URLs.",
        imagesFolder: "Images folder",
        imagesFolderDesc: "Folder where downloaded images will be saved.",
        imagesFolderPlaceholder: "Example: attachments/TMDB",
        savePosterImage: "Save poster images",
        savePosterImageDesc: "Download and save movie/series poster images.",
        saveCoverImage: "Save cover/backdrop images",
        saveCoverImageDesc: "Download and save movie/series cover/backdrop images.",
        saveLogoImage: "Save logo images",
        saveLogoImageDesc: "Download and save movie/series logo images.",
        moviesHeading: "Movies",
        movieFileName: "Movie file name",
        movieFileNameDesc: "Enter the movie file name format.",
        movieFileNamePlaceholder: "Example: {{nameForFile}} ({{year}})",
        movieFileLocation: "Movie file location",
        movieFileLocationDesc: "New movie notes will be placed here.",
        movieFileLocationPlaceholder: "Example: folder1/folder2",
        movieTemplateFile: "Movie template file",
        movieTemplateFileDesc: "Files will be available as templates.",
        movieTemplateFilePlaceholder: "Example: templates/template-file",
        exampleTemplate: "Example Template",
        seriesHeading: "TV series",
        seriesFileName: "TV series file name",
        seriesFileNameDesc: "Enter the TV series file name format.",
        seriesFileNamePlaceholder: "Example: {{nameForFile}} ({{year}})",
        seriesFileLocation: "TV series file location",
        seriesFileLocationDesc: "New TV series notes will be placed here.",
        seriesFileLocationPlaceholder: "Example: folder1/folder2",
        seriesTemplateFile: "TV series template file",
        seriesTemplateFileDesc: "Files will be available as templates.",
        seriesTemplateFilePlaceholder: "Example: templates/template-file",
        actorHeading: "Actor Settings",
        language: "Interface language",
        languageDesc: "Select the plugin interface language.",
        // Mobile settings
        mobileSettings: "Mobile Settings",
        mobileCoverHeightMultiplier: "Cover Height Multiplier",
        mobileCoverHeightMultiplierDesc: "Multiplier for cover height on mobile devices (default: 1.5)",
        actorFolder: "Actors folder",
        actorFolderDesc: "Folder where actor notes will be created",
        actorTemplate: "Actor template file",
        actorTemplateDesc: "Template that will be used to create actor notes",
        actorFileNameFormat: "Actor filename format",
        actorFileNameFormatDesc: "Filename format for actors. Available variables: {{id}}, {{nameForFile}}, {{enNameForFile}}",
        validateToken: "Test token"
      },
      status: {
        selectStatus: "Select status:",
        willWatch: "Will watch",
        haveWatched: "Have watched",
        watching: "Watching",
        dropped: "Dropped",
        skip: "Skip",
        useDefault: "Use default status",
        defaultStatus: "Will watch"
      },
      ratings: {
        myRating: "My Rating",
        kinopoiskRating: "Kinopoisk Rating",
        year: "Year"
      }
    };
    translations = {
      ru,
      en
    };
    currentLanguage = "en";
  }
});

// APIProvider/ErrorHandler.ts
var NETWORK_ERROR_PATTERNS, ErrorHandler;
var init_ErrorHandler = __esm({
  "APIProvider/ErrorHandler.ts"() {
    init_i18n();
    NETWORK_ERROR_PATTERNS = [
      "net::",
      "NetworkError",
      "Failed to fetch",
      "ENOTFOUND",
      "ECONNREFUSED",
      "ETIMEDOUT"
    ];
    ErrorHandler = class {
      /**
       * Returns localized error message for HTTP status code
       */
      getHttpStatusMessage(status) {
        const statusMessages = {
          400: t("errorHandler.badRequest"),
          401: t("errorHandler.unauthorized"),
          403: t("errorHandler.forbidden"),
          404: t("errorHandler.notFound"),
          429: t("errorHandler.tooManyRequests"),
          500: t("errorHandler.internalServerError"),
          502: t("errorHandler.badGateway"),
          503: t("errorHandler.serviceUnavailable"),
          504: t("errorHandler.gatewayTimeout")
        };
        return statusMessages[status] || "";
      }
      /**
       * Processes API errors and creates user-friendly error messages
       */
      handleApiError(error) {
        const errorDetails = this.extractErrorDetails(error);
        if (errorDetails.isNetworkError) {
          return new Error(t("errorHandler.networkError"));
        }
        const knownMessage = this.getHttpStatusMessage(errorDetails.status);
        if (knownMessage) {
          return new Error(knownMessage);
        }
        if (errorDetails.status > 0) {
          return new Error(
            tWithParams("errorHandler.unknownStatusError", {
              status: errorDetails.status.toString()
            })
          );
        }
        return new Error(t("errorHandler.unexpectedError"));
      }
      /**
       * Extracts error details from various error formats
       */
      extractErrorDetails(error) {
        const details = {
          status: 0,
          message: "",
          isNetworkError: false,
          originalError: error
        };
        if (this.isNetworkError(error)) {
          details.isNetworkError = true;
          return details;
        }
        details.status = this.extractStatusCode(error);
        return details;
      }
      isNetworkError(error) {
        if (!(error instanceof Error)) {
          return false;
        }
        return NETWORK_ERROR_PATTERNS.some(
          (pattern) => error.message.includes(pattern)
        );
      }
      /**
       * Extracts HTTP status code from error object
       */
      extractStatusCode(error) {
        if (!error || typeof error !== "object") {
          return 0;
        }
        if ("status" in error && typeof error.status === "number") {
          return error.status;
        }
        if ("response" in error && error.response && typeof error.response === "object" && "status" in error.response && typeof error.response.status === "number") {
          return error.response.status;
        }
        if ("statusCode" in error && typeof error.statusCode === "number") {
          return error.statusCode;
        }
        return 0;
      }
      logError(context, error) {
        console.error(`[${context}] Error:`, error);
      }
    };
  }
});

// Utils/utils.ts
function capitalizeFirstLetter(input) {
  if (!input || input.length === 0) {
    return input || "";
  }
  return input.charAt(0).toUpperCase() + input.slice(1);
}
function replaceIllegalFileNameCharactersInString(text) {
  if (!text) {
    return "";
  }
  return text.replace(/[\\/:*?"<>|]/g, "");
}
function getPlainValueFromArray(value) {
  if (Array.isArray(value)) {
    if (value.length === 0) return "";
    if (value.length === 1) {
      const firstValue = value[0];
      if (typeof firstValue === "string") {
        return firstValue.replace(/^"(.*)"$/, "$1");
      }
      return firstValue != null ? firstValue : "";
    }
    return value.filter((item) => item != null).map((item) => {
      if (typeof item === "string") {
        return item.replace(/^"(.*)"$/, "$1");
      }
      return String(item);
    }).join(", ");
  }
  if (typeof value === "number") {
    return value;
  }
  return String(value || "");
}
function getQuotedValueFromArray(value) {
  if (Array.isArray(value)) {
    if (value.length === 0) return "";
    if (value.length === 1) {
      const firstValue = String(value[0] || "");
      if (firstValue.startsWith("![[") || firstValue.startsWith("![](")) {
        if (!firstValue.startsWith('"') && !firstValue.endsWith('"')) {
          return `"${firstValue}"`;
        }
      }
      if (firstValue.startsWith('"') && firstValue.endsWith('"')) {
        const innerText = firstValue.slice(1, -1);
        const escapedInnerText = innerText.replace(/"/g, '\\"');
        return `"${escapedInnerText}"`;
      }
      return firstValue;
    }
    return value.filter((item) => item != null).map((item) => {
      const itemStr = String(item);
      if (itemStr.startsWith("![[") || itemStr.startsWith("![](")) {
        if (!itemStr.startsWith('"') && !itemStr.endsWith('"')) {
          return `"${itemStr}"`;
        }
      }
      if (itemStr.startsWith('"') && itemStr.endsWith('"')) {
        const innerText = itemStr.slice(1, -1);
        const escapedInnerText = innerText.replace(/"/g, '\\"');
        return `"${escapedInnerText}"`;
      }
      return itemStr;
    }).join(", ");
  }
  const stringValue = String(value || "");
  if (stringValue.startsWith('"') && stringValue.endsWith('"')) {
    const innerText = stringValue.slice(1, -1);
    const escapedInnerText = innerText.replace(/"/g, '\\"');
    return `"${escapedInnerText}"`;
  }
  return stringValue;
}
function replaceVariableSyntax(movieShow, text) {
  if (!(text == null ? void 0 : text.trim())) {
    return "";
  }
  try {
    const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
    const match = text.match(frontmatterRegex);
    if (match) {
      const [, frontmatter, body] = match;
      const processedFrontmatter = Object.entries(movieShow).reduce(
        (result2, [key, val = ""]) => {
          try {
            const quotedValue = getQuotedValueFromArray(val);
            return result2.replace(
              new RegExp(`{{${key}}}`, "ig"),
              quotedValue
            );
          } catch (error) {
            console.error(
              `Error processing frontmatter variable ${key}:`,
              error
            );
            return result2;
          }
        },
        frontmatter
      );
      const processedBody = Object.entries(movieShow).reduce(
        (result2, [key, val = ""]) => {
          try {
            const plainValue = getPlainValueFromArray(val);
            return result2.replace(
              new RegExp(`{{${key}}}`, "ig"),
              String(plainValue)
            );
          } catch (error) {
            console.error(
              `Error processing body variable ${key}:`,
              error
            );
            return result2;
          }
        },
        body
      );
      const result = `---
${processedFrontmatter}
---
${processedBody}`;
      return result.replace(/{{\w+}}/gi, "").trim();
    } else {
      const entries = Object.entries(movieShow);
      return entries.reduce((result, [key, val = ""]) => {
        try {
          const plainValue = getPlainValueFromArray(val);
          return result.replace(
            new RegExp(`{{${key}}}`, "ig"),
            String(plainValue)
          );
        } catch (error) {
          console.error(
            `Error processing variable ${key}:`,
            error
          );
          return result;
        }
      }, text).replace(/{{\w+}}/gi, "").trim();
    }
  } catch (error) {
    console.error("Error in replaceVariableSyntax:", error);
    return text;
  }
}
async function makeFileName(app, movieShow, fileNameFormat, folderPath) {
  try {
    let baseName;
    if (fileNameFormat) {
      baseName = replaceVariableSyntax(movieShow, fileNameFormat);
    } else {
      baseName = `${movieShow.nameForFile || t("utils.unknownMovie")} (${movieShow.year || t("utils.unknownMovie")})`;
    }
    const cleanedBaseName = replaceIllegalFileNameCharactersInString(baseName);
    if (!cleanedBaseName.trim()) {
      return `${t("utils.unknownMovie")}.md`;
    }
    const fileName = cleanedBaseName + ".md";
    const { vault } = app;
    const fullPath = folderPath ? `${folderPath}/${fileName}` : fileName;
    const normalizedPath = (0, import_obsidian.normalizePath)(fullPath);
    if (!vault.getAbstractFileByPath(normalizedPath)) {
      return fileName;
    }
    let copyNumber = 1;
    let copyFileName;
    let copyFullPath;
    do {
      copyFileName = `${cleanedBaseName} (${t(
        "utils.copyPrefix"
      )}[${copyNumber}]).md`;
      copyFullPath = folderPath ? `${folderPath}/${copyFileName}` : copyFileName;
      copyNumber++;
    } while (vault.getAbstractFileByPath((0, import_obsidian.normalizePath)(copyFullPath)));
    return copyFileName;
  } catch (error) {
    console.error("Error creating file name:", error);
    return `${t("utils.unknownMovie")}.md`;
  }
}
async function getTemplateContents(app, templatePath) {
  if (!templatePath || templatePath === "/") {
    return "";
  }
  try {
    const { metadataCache, vault } = app;
    const normalizedTemplatePath = (0, import_obsidian.normalizePath)(templatePath);
    const templateFile = metadataCache.getFirstLinkpathDest(
      normalizedTemplatePath,
      ""
    );
    if (!templateFile) {
      console.warn(
        `${t("utils.templateNotFound")}: ${normalizedTemplatePath}`
      );
      return "";
    }
    return await vault.cachedRead(templateFile);
  } catch (error) {
    console.error(`Failed to read the template '${templatePath}':`, error);
    new import_obsidian.Notice(t("utils.templateReadError"));
    return "";
  }
}
var import_obsidian;
var init_utils = __esm({
  "Utils/utils.ts"() {
    import_obsidian = require("obsidian");
    init_i18n();
  }
});

// APIProvider/DataFormatter.ts
var MAX_ARRAY_ITEMS, MAX_FACTS_COUNT, TMDB_CONFIG, AGE_RATING_MAP, PROFESSION_MAP, TYPE_TRANSLATIONS, HTML_ENTITIES, DataFormatter;
var init_DataFormatter = __esm({
  "APIProvider/DataFormatter.ts"() {
    init_utils();
    MAX_ARRAY_ITEMS = 50;
    MAX_FACTS_COUNT = 5;
    TMDB_CONFIG = {
      IMAGE_BASE_URL: "https://image.tmdb.org/t/p/",
      SIZES: {
        POSTER_ORIGINAL: "original",
        POSTER_W500: "w500",
        POSTER_W185: "w185",
        BACKDROP_ORIGINAL: "original",
        BACKDROP_W1280: "w1280",
        PROFILE_W185: "w185"
      }
    };
    AGE_RATING_MAP = {
      MOVIE: {
        "G": 0,
        "PG": 6,
        "PG-13": 13,
        "R": 17,
        "NC-17": 18
      },
      TV: {
        "TV-Y": 0,
        "TV-Y7": 7,
        "TV-G": 0,
        "TV-PG": 10,
        "TV-14": 14,
        "TV-MA": 17
      }
    };
    PROFESSION_MAP = {
      "Director": { enProfession: "director", profession: "\u0440\u0435\u0436\u0438\u0441\u0441\u0435\u0440" },
      "Writer": { enProfession: "writer", profession: "\u0441\u0446\u0435\u043D\u0430\u0440\u0438\u0441\u0442" },
      "Screenplay": { enProfession: "writer", profession: "\u0441\u0446\u0435\u043D\u0430\u0440\u0438\u0441\u0442" },
      "Producer": { enProfession: "producer", profession: "\u043F\u0440\u043E\u0434\u044E\u0441\u0435\u0440" },
      "Executive Producer": { enProfession: "producer", profession: "\u043F\u0440\u043E\u0434\u044E\u0441\u0435\u0440" }
    };
    TYPE_TRANSLATIONS = {
      "animated-series": "\u0410\u043D\u0438\u043C\u0430\u0446\u0438\u043E\u043D\u043D\u044B\u0439 \u0441\u0435\u0440\u0438\u0430\u043B",
      anime: "\u0410\u043D\u0438\u043C\u0435",
      cartoon: "\u041C\u0443\u043B\u044C\u0442\u0444\u0438\u043B\u044C\u043C",
      movie: "\u0424\u0438\u043B\u044C\u043C",
      "tv-series": "\u0421\u0435\u0440\u0438\u0430\u043B"
    };
    HTML_ENTITIES = {
      "&laquo;": "\xAB",
      "&raquo;": "\xBB",
      "&ldquo;": '"',
      "&rdquo;": '"',
      "&lsquo;": "'",
      "&rsquo;": "'",
      "&quot;": '"',
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&nbsp;": " ",
      "&ndash;": "\u2013",
      "&mdash;": "\u2014",
      "&hellip;": "\u2026"
    };
    DataFormatter = class {
      /**
       * Set settings for path support
       */
      setSettings(settings) {
        this.settings = settings;
      }
      /**
       * Build TMDB image URL
       */
      buildImageUrl(path, size) {
        return `${TMDB_CONFIG.IMAGE_BASE_URL}${size}${path}`;
      }
      /**
       * Extract best image by language priority (ru -> en -> any)
       */
      extractBestImage(images, type) {
        if (!images || images.length === 0) {
          return void 0;
        }
        const ruImage = images.find((img) => img.iso_639_1 === "ru");
        if (ruImage) {
          return {
            url: this.buildImageUrl(ruImage.file_path, TMDB_CONFIG.SIZES.POSTER_ORIGINAL),
            previewUrl: this.buildImageUrl(ruImage.file_path, TMDB_CONFIG.SIZES.POSTER_W500)
          };
        }
        const enImage = images.find((img) => img.iso_639_1 === "en");
        if (enImage) {
          return {
            url: this.buildImageUrl(enImage.file_path, TMDB_CONFIG.SIZES.POSTER_ORIGINAL),
            previewUrl: this.buildImageUrl(enImage.file_path, TMDB_CONFIG.SIZES.POSTER_W500)
          };
        }
        const anyImage = images[0];
        return {
          url: this.buildImageUrl(anyImage.file_path, TMDB_CONFIG.SIZES.POSTER_ORIGINAL),
          previewUrl: this.buildImageUrl(anyImage.file_path, TMDB_CONFIG.SIZES.POSTER_W500)
        };
      }
      /**
       * Convert TMDB credits to persons format
       */
      convertCreditsToPersons(credits) {
        const persons = [];
        (credits.cast || []).slice(0, 20).forEach((person) => {
          persons.push({
            id: person.id,
            name: person.name,
            enName: person.original_name || person.name,
            enProfession: "actor",
            profession: "\u0430\u043A\u0442\u0435\u0440",
            photo: person.profile_path ? this.buildImageUrl(person.profile_path, TMDB_CONFIG.SIZES.PROFILE_W185) : void 0
          });
        });
        (credits.crew || []).forEach((person) => {
          const mapping = PROFESSION_MAP[person.job];
          if (!mapping && person.department === "Writing") {
            persons.push({
              id: person.id,
              name: person.name,
              enName: person.original_name || person.name,
              enProfession: "writer",
              profession: "\u0441\u0446\u0435\u043D\u0430\u0440\u0438\u0441\u0442",
              photo: person.profile_path ? this.buildImageUrl(person.profile_path, TMDB_CONFIG.SIZES.PROFILE_W185) : void 0
            });
          } else if (mapping) {
            persons.push({
              id: person.id,
              name: person.name,
              enName: person.original_name || person.name,
              enProfession: mapping.enProfession,
              profession: mapping.profession,
              photo: person.profile_path ? this.buildImageUrl(person.profile_path, TMDB_CONFIG.SIZES.PROFILE_W185) : void 0
            });
          }
        });
        return persons;
      }
      /**
       * Extract age rating from TMDB release dates
       */
      extractAgeRating(releaseDates) {
        var _a, _b;
        if (!(releaseDates == null ? void 0 : releaseDates.results)) return 0;
        const usRelease = releaseDates.results.find((r) => r.iso_3166_1 === "US");
        if ((_b = (_a = usRelease == null ? void 0 : usRelease.release_dates) == null ? void 0 : _a[0]) == null ? void 0 : _b.certification) {
          const cert = usRelease.release_dates[0].certification;
          return AGE_RATING_MAP.MOVIE[cert] || 0;
        }
        return 0;
      }
      /**
       * Extract MPAA rating string
       */
      extractMpaaRating(releaseDates) {
        var _a, _b;
        if (!(releaseDates == null ? void 0 : releaseDates.results)) return "";
        const usRelease = releaseDates.results.find((r) => r.iso_3166_1 === "US");
        return ((_b = (_a = usRelease == null ? void 0 : usRelease.release_dates) == null ? void 0 : _a[0]) == null ? void 0 : _b.certification) || "";
      }
      /**
       * Extract age rating for TV shows
       */
      extractTVAgeRating(contentRatings) {
        if (!(contentRatings == null ? void 0 : contentRatings.results)) return 0;
        const usRating = contentRatings.results.find((r) => r.iso_3166_1 === "US");
        if (usRating == null ? void 0 : usRating.rating) {
          return AGE_RATING_MAP.TV[usRating.rating] || 0;
        }
        return 0;
      }
      /**
       * Convert TMDB movie data to TMDBFullInfo format
       */
      convertMovieToTMDBFormat(details, credits, images) {
        var _a, _b, _c, _d, _e;
        const year = details.release_date ? parseInt(details.release_date.substring(0, 4)) : 0;
        const poster = ((_a = images == null ? void 0 : images.posters) == null ? void 0 : _a.length) > 0 ? this.extractBestImage(images.posters, "poster") : details.poster_path ? {
          url: this.buildImageUrl(details.poster_path, TMDB_CONFIG.SIZES.POSTER_ORIGINAL),
          previewUrl: this.buildImageUrl(details.poster_path, TMDB_CONFIG.SIZES.POSTER_W500)
        } : void 0;
        const backdrop = ((_b = images == null ? void 0 : images.backdrops) == null ? void 0 : _b.length) > 0 ? this.extractBestImage(images.backdrops, "backdrop") : details.backdrop_path ? {
          url: this.buildImageUrl(details.backdrop_path, TMDB_CONFIG.SIZES.BACKDROP_ORIGINAL),
          previewUrl: this.buildImageUrl(details.backdrop_path, TMDB_CONFIG.SIZES.BACKDROP_W1280)
        } : void 0;
        const logo = ((_c = images == null ? void 0 : images.logos) == null ? void 0 : _c.length) > 0 ? this.extractBestImage(images.logos, "logo") : void 0;
        return {
          id: details.id,
          name: details.title || "",
          alternativeName: details.original_title || "",
          enName: details.original_language === "en" ? details.original_title : details.title,
          type: "movie",
          year,
          description: details.overview || "",
          shortDescription: details.tagline || "",
          poster,
          backdrop,
          logo,
          genres: (details.genres || []).map((g) => ({ name: g.name })),
          countries: (details.production_countries || []).map((c) => ({ name: c.name })),
          persons: this.convertCreditsToPersons(credits),
          movieLength: details.runtime || 0,
          isSeries: false,
          TMDBLink: details.homepage,
          rating: {
            tmdb: details.vote_average || 0,
            imdb: details.vote_average || 0
          },
          votes: {
            tmdb: details.vote_count || 0,
            imdb: details.vote_count || 0
          },
          externalId: {
            imdb: details.imdb_id,
            tmdb: details.id
          },
          slogan: details.tagline,
          budget: details.budget ? {
            value: details.budget,
            currency: "USD"
          } : void 0,
          fees: details.revenue ? {
            world: {
              value: details.revenue,
              currency: "USD"
            }
          } : void 0,
          premiere: {
            world: details.release_date
          },
          ageRating: this.extractAgeRating(details.release_dates),
          ratingMpaa: this.extractMpaaRating(details.release_dates),
          productionCompanies: (details.production_companies || []).map((c) => ({
            name: c.name
          })),
          networks: details.networks ? {
            items: details.networks.map((n) => ({ name: n.name }))
          } : void 0,
          names: ((_e = (_d = details.alternative_titles) == null ? void 0 : _d.titles) == null ? void 0 : _e.map((t2) => ({
            name: t2.title,
            type: t2.type
          }))) || []
        };
      }
      /**
       * Convert TMDB TV show data to TMDBFullInfo format
       */
      convertTVShowToTMDBFormat(details, credits, images) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const year = details.first_air_date ? parseInt(details.first_air_date.substring(0, 4)) : 0;
        const poster = ((_a = images == null ? void 0 : images.posters) == null ? void 0 : _a.length) > 0 ? this.extractBestImage(images.posters, "poster") : details.poster_path ? {
          url: this.buildImageUrl(details.poster_path, TMDB_CONFIG.SIZES.POSTER_ORIGINAL),
          previewUrl: this.buildImageUrl(details.poster_path, TMDB_CONFIG.SIZES.POSTER_W500)
        } : void 0;
        const backdrop = ((_b = images == null ? void 0 : images.backdrops) == null ? void 0 : _b.length) > 0 ? this.extractBestImage(images.backdrops, "backdrop") : details.backdrop_path ? {
          url: this.buildImageUrl(details.backdrop_path, TMDB_CONFIG.SIZES.BACKDROP_ORIGINAL),
          previewUrl: this.buildImageUrl(details.backdrop_path, TMDB_CONFIG.SIZES.BACKDROP_W1280)
        } : void 0;
        const logo = ((_c = images == null ? void 0 : images.logos) == null ? void 0 : _c.length) > 0 ? this.extractBestImage(images.logos, "logo") : void 0;
        return {
          id: details.id,
          name: details.name || "",
          alternativeName: details.original_name || "",
          enName: details.original_language === "en" ? details.original_name : details.name,
          type: "tv-series",
          year,
          description: details.overview || "",
          shortDescription: details.tagline || "",
          poster,
          backdrop,
          logo,
          genres: (details.genres || []).map((g) => ({ name: g.name })),
          countries: (details.production_countries || []).map((c) => ({ name: c.name })),
          persons: this.convertCreditsToPersons(credits),
          isSeries: true,
          TMDBLink: details.homepage,
          seriesLength: ((_d = details.episode_run_time) == null ? void 0 : _d[0]) || 0,
          totalSeriesLength: (details.number_of_episodes || 0) * (((_e = details.episode_run_time) == null ? void 0 : _e[0]) || 0),
          status: details.status,
          seasonsInfo: (details.seasons || []).filter((s) => s.season_number > 0).map((s) => ({
            number: s.season_number,
            episodesCount: s.episode_count
          })),
          rating: {
            tmdb: details.vote_average || 0,
            imdb: details.vote_average || 0
          },
          votes: {
            tmdb: details.vote_count || 0,
            imdb: details.vote_count || 0
          },
          externalId: {
            imdb: (_f = details.external_ids) == null ? void 0 : _f.imdb_id,
            tmdb: details.id
          },
          premiere: {
            world: details.first_air_date
          },
          releaseYears: [{
            start: year,
            end: details.last_air_date ? parseInt(details.last_air_date.substring(0, 4)) : void 0
          }],
          ageRating: this.extractTVAgeRating(details.content_ratings),
          productionCompanies: (details.production_companies || []).map((c) => ({
            name: c.name
          })),
          networks: {
            items: (details.networks || []).map((n) => ({ name: n.name }))
          },
          names: ((_h = (_g = details.alternative_titles) == null ? void 0 : _g.results) == null ? void 0 : _h.map((t2) => ({
            name: t2.title,
            type: t2.type
          }))) || []
        };
      }
      /**
       * Transforms API data into MovieShow format
       */
      createMovieShowFrom(fullInfo, userRating) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, __;
        const seasonsData = this.calculateSeasonsData(fullInfo.seasonsInfo);
        const people = this.extractPeople(fullInfo.persons || []);
        const companies = this.extractCompanies(fullInfo);
        const facts = this.processFacts(fullInfo.facts || []);
        const names = this.processNames(fullInfo);
        const firstReleaseYear = (_a = fullInfo.releaseYears) == null ? void 0 : _a[0];
        const item = {
          // Basic information
          id: fullInfo.id,
          name: this.formatArray([fullInfo.name], "short" /* SHORT_VALUE */),
          alternativeName: this.formatArray(
            [fullInfo.alternativeName || ""],
            "short" /* SHORT_VALUE */
          ),
          year: fullInfo.year,
          description: this.formatArray(
            [fullInfo.description || ""],
            "long" /* LONG_TEXT */
          ),
          shortDescription: this.formatArray(
            [fullInfo.shortDescription || ""],
            "long" /* LONG_TEXT */
          ),
          // Additional properties for filenames
          nameForFile: this.cleanTextForMetadata(fullInfo.name),
          alternativeNameForFile: this.cleanTextForMetadata(
            fullInfo.alternativeName || ""
          ),
          enNameForFile: this.cleanTextForMetadata(fullInfo.enName || ""),
          // TMDB Link
          TMDBLink: this.formatArray(
            [fullInfo.type === "person" ? `https://www.themoviedb.org/person/${fullInfo.id}` : `https://www.themoviedb.org/${fullInfo.type === "tv-series" ? "tv" : "movie"}/${fullInfo.id}`],
            "url" /* URL */
          ),
          // Images
          posterUrl: this.formatArray(
            [((_b = fullInfo.poster) == null ? void 0 : _b.url) || ""],
            "url" /* URL */
          ),
          coverUrl: this.formatArray(
            [((_c = fullInfo.backdrop) == null ? void 0 : _c.url) || ""],
            "url" /* URL */
          ),
          logoUrl: this.formatArray(
            [((_d = fullInfo.logo) == null ? void 0 : _d.url) || ""],
            "url" /* URL */
          ),
          // Ready-to-use image links for Obsidian
          posterMarkdown: this.createImageLink(((_e = fullInfo.poster) == null ? void 0 : _e.url) || ""),
          coverMarkdown: this.createImageLink(((_f = fullInfo.backdrop) == null ? void 0 : _f.url) || ""),
          logoMarkdown: this.createImageLink(((_g = fullInfo.logo) == null ? void 0 : _g.url) || ""),
          // Clean image paths for template sizing
          posterPath: [],
          coverPath: [],
          logoPath: [],
          coverPathMobile: [],
          // Classification
          genres: this.formatArray(
            fullInfo.genres.map((g) => capitalizeFirstLetter(g.name)),
            "short" /* SHORT_VALUE */
          ),
          genresLinks: this.formatArray(
            fullInfo.genres.map((g) => capitalizeFirstLetter(g.name)),
            "link" /* LINK */
          ),
          countries: this.formatArray(
            fullInfo.countries.map((c) => c.name),
            "short" /* SHORT_VALUE */
          ),
          countriesLinks: this.formatArray(
            fullInfo.countries.map((c) => c.name),
            "link" /* LINK */
          ),
          type: this.formatArray(
            [this.translateType(fullInfo.type || "")],
            "short" /* SHORT_VALUE */
          ),
          subType: this.formatArray(
            [fullInfo.subType || ""],
            "short" /* SHORT_VALUE */
          ),
          // People
          director: this.formatArray(people.directors, "short" /* SHORT_VALUE */),
          directorsLinks: this.formatArray(people.directors, "link" /* LINK */),
          directorsLinksWithPath: this.formatArray(
            people.directors,
            "link_with_path" /* LINK_WITH_PATH */,
            (_h = this.settings) == null ? void 0 : _h.directorsPath
          ),
          directorsIdsWithPath: this.formatArray(
            people.directors,
            "link_id_with_path" /* LINK_ID_WITH_PATH */,
            (_i = this.settings) == null ? void 0 : _i.directorsPath
          ),
          actors: this.formatArray(people.actors, "short" /* SHORT_VALUE */),
          actorsLinks: this.formatArray(people.actors, "link" /* LINK */),
          actorsLinksWithPath: this.formatArray(
            people.actors,
            "link_with_path" /* LINK_WITH_PATH */,
            (_j = this.settings) == null ? void 0 : _j.actorsPath
          ),
          actorsIdsWithPath: this.formatArray(
            people.actors,
            "link_id_with_path" /* LINK_ID_WITH_PATH */,
            (_k = this.settings) == null ? void 0 : _k.actorsPath
          ),
          writers: this.formatArray(people.writers, "short" /* SHORT_VALUE */),
          writersLinks: this.formatArray(people.writers, "link" /* LINK */),
          writersLinksWithPath: this.formatArray(
            people.writers,
            "link_with_path" /* LINK_WITH_PATH */,
            (_l = this.settings) == null ? void 0 : _l.writersPath
          ),
          writersIdsWithPath: this.formatArray(
            people.writers,
            "link_id_with_path" /* LINK_ID_WITH_PATH */,
            (_m = this.settings) == null ? void 0 : _m.writersPath
          ),
          producers: this.formatArray(people.producers, "short" /* SHORT_VALUE */),
          producersLinks: this.formatArray(people.producers, "link" /* LINK */),
          producersLinksWithPath: this.formatArray(
            people.producers,
            "link_with_path" /* LINK_WITH_PATH */,
            (_n = this.settings) == null ? void 0 : _n.producersPath
          ),
          producersIdsWithPath: this.formatArray(
            people.producers,
            "link_id_with_path" /* LINK_ID_WITH_PATH */,
            (_o = this.settings) == null ? void 0 : _o.producersPath
          ),
          // Technical specifications
          movieLength: fullInfo.movieLength || 0,
          isSeries: fullInfo.isSeries,
          seriesLength: fullInfo.seriesLength || 0,
          totalSeriesLength: fullInfo.totalSeriesLength || 0,
          isComplete: fullInfo.isSeries ? fullInfo.status === "Ended" || fullInfo.status === "Canceled" ? "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D" : "\u0412 \u044D\u0444\u0438\u0440\u0435" : "\u0412\u044B\u0448\u0435\u043B",
          seasonsCount: seasonsData.count,
          seriesInSeasonCount: seasonsData.averageEpisodesPerSeason,
          // Ratings and votes
          ratingTmdb: ((_p = fullInfo.rating) == null ? void 0 : _p.tmdb) ? Number((_r = (_q = fullInfo.rating) == null ? void 0 : _q.tmdb) == null ? void 0 : _r.toFixed(1)) : 0,
          ratingImdb: ((_s = fullInfo.rating) == null ? void 0 : _s.imdb) ? Number((_u = (_t = fullInfo.rating) == null ? void 0 : _t.imdb) == null ? void 0 : _u.toFixed(1)) : 0,
          ratingFilmCritics: ((_v = fullInfo.rating) == null ? void 0 : _v.filmCritics) || 0,
          ratingRussianFilmCritics: ((_w = fullInfo.rating) == null ? void 0 : _w.russianFilmCritics) || 0,
          votesTmdb: ((_x = fullInfo.votes) == null ? void 0 : _x.tmdb) || 0,
          votesImdb: ((_y = fullInfo.votes) == null ? void 0 : _y.imdb) || 0,
          votesFilmCritics: ((_z = fullInfo.votes) == null ? void 0 : _z.filmCritics) || 0,
          votesRussianFilmCritics: ((_A = fullInfo.votes) == null ? void 0 : _A.russianFilmCritics) || 0,
          // External IDs and links
          TMDBUrl: this.formatArray(
            [`https://www.themoviedb.org/${fullInfo.type === "tv-series" ? "tv" : "movie"}/${fullInfo.id}`],
            "url" /* URL */
          ),
          imdbId: this.formatArray(
            [((_B = fullInfo.externalId) == null ? void 0 : _B.imdb) || ""],
            "short" /* SHORT_VALUE */
          ),
          tmdbId: ((_C = fullInfo.externalId) == null ? void 0 : _C.tmdb) || 0,
          // Additional information
          slogan: this.formatArray(
            [fullInfo.slogan || ""],
            "long" /* LONG_TEXT */
          ),
          ageRating: fullInfo.ageRating || 0,
          ratingMpaa: this.formatArray(
            [fullInfo.ratingMpaa || ""],
            "short" /* SHORT_VALUE */
          ),
          // Status - initially empty, will be set separately
          status: this.formatArray([""], "short" /* SHORT_VALUE */),
          // Financial data
          budgetValue: ((_D = fullInfo.budget) == null ? void 0 : _D.value) || 0,
          budgetCurrency: this.formatArray(
            [((_E = fullInfo.budget) == null ? void 0 : _E.currency) || ""],
            "short" /* SHORT_VALUE */
          ),
          feesWorldValue: ((_G = (_F = fullInfo.fees) == null ? void 0 : _F.world) == null ? void 0 : _G.value) || 0,
          feesWorldCurrency: this.formatArray(
            [((_I = (_H = fullInfo.fees) == null ? void 0 : _H.world) == null ? void 0 : _I.currency) || ""],
            "short" /* SHORT_VALUE */
          ),
          feesRussiaValue: ((_K = (_J = fullInfo.fees) == null ? void 0 : _J.russia) == null ? void 0 : _K.value) || 0,
          feesRussiaCurrency: this.formatArray(
            [((_M = (_L = fullInfo.fees) == null ? void 0 : _L.russia) == null ? void 0 : _M.currency) || ""],
            "short" /* SHORT_VALUE */
          ),
          feesUsaValue: ((_O = (_N = fullInfo.fees) == null ? void 0 : _N.usa) == null ? void 0 : _O.value) || 0,
          feesUsaCurrency: this.formatArray(
            [((_Q = (_P = fullInfo.fees) == null ? void 0 : _P.usa) == null ? void 0 : _Q.currency) || ""],
            "short" /* SHORT_VALUE */
          ),
          // Premiere dates
          premiereWorld: this.formatArray(
            [this.formatDate((_R = fullInfo.premiere) == null ? void 0 : _R.world)],
            "short" /* SHORT_VALUE */
          ),
          premiereRussia: this.formatArray(
            [this.formatDate((_S = fullInfo.premiere) == null ? void 0 : _S.russia)],
            "short" /* SHORT_VALUE */
          ),
          premiereDigital: this.formatArray(
            [this.formatDate((_T = fullInfo.premiere) == null ? void 0 : _T.digital)],
            "short" /* SHORT_VALUE */
          ),
          premiereCinema: this.formatArray(
            [this.formatDate((_U = fullInfo.premiere) == null ? void 0 : _U.cinema)],
            "short" /* SHORT_VALUE */
          ),
          // Release years
          releaseYearsStart: (firstReleaseYear == null ? void 0 : firstReleaseYear.start) || 0,
          releaseYearsEnd: (firstReleaseYear == null ? void 0 : firstReleaseYear.end) || 0,
          // Top ratings
          top10: fullInfo.top10 || 0,
          top250: fullInfo.top250 || 0,
          // Facts
          facts: this.formatArray(facts, "long" /* LONG_TEXT */),
          // Alternative names
          allNamesString: this.formatArray(
            names.allNames,
            "short" /* SHORT_VALUE */
          ),
          enName: this.formatArray(
            [fullInfo.enName || ""],
            "short" /* SHORT_VALUE */
          ),
          // Networks and companies
          networks: this.formatArray(
            companies.networks,
            "short" /* SHORT_VALUE */
          ),
          networksLinks: this.formatArray(
            companies.networks,
            "link" /* LINK */
          ),
          productionCompanies: this.formatArray(
            companies.productionCompanies,
            "short" /* SHORT_VALUE */
          ),
          productionCompaniesLinks: this.formatArray(
            companies.productionCompanies,
            "link" /* LINK */
          ),
          // Distributors
          distributor: this.formatArray(
            [((_V = fullInfo.distributors) == null ? void 0 : _V.distributor) || ""],
            "short" /* SHORT_VALUE */
          ),
          distributorRelease: this.formatArray(
            [
              this.formatDate(
                (_W = fullInfo.distributors) == null ? void 0 : _W.distributorRelease
              ) || ((_X = fullInfo.distributors) == null ? void 0 : _X.distributorRelease) || ""
            ],
            "short" /* SHORT_VALUE */
          ),
          // Related movies/series
          sequelsAndPrequels: this.formatArray(
            companies.sequelsAndPrequels,
            "short" /* SHORT_VALUE */
          ),
          sequelsAndPrequelsLinks: this.formatArray(
            companies.sequelsAndPrequels,
            "link" /* LINK */
          ),
          // Actor-specific fields (only populate if it's a person)
          ...fullInfo.type === "person" ? {
            sex: this.formatArray([fullInfo.gender === 1 ? "\u0416\u0435\u043D\u0441\u043A\u0438\u0439" : fullInfo.gender === 2 ? "\u041C\u0443\u0436\u0441\u043A\u043E\u0439" : "\u041D\u0435 \u0443\u043A\u0430\u0437\u0430\u043D"], "short" /* SHORT_VALUE */),
            spouses: this.formatArray([], "short" /* SHORT_VALUE */),
            // TMDB doesn't provide spouse information directly
            birthday: this.formatArray([((_Y = fullInfo.premiere) == null ? void 0 : _Y.world) || ""], "short" /* SHORT_VALUE */),
            // Using world premiere (birthday) from fullInfo
            death: this.formatArray([fullInfo.deathday || ""], "short" /* SHORT_VALUE */),
            growth: this.formatArray([fullInfo.knownForDepartment || ""], "short" /* SHORT_VALUE */),
            // Using knownForDepartment as growth
            kinopoiskUrl: this.formatArray([fullInfo.TMDBLink || ""], "url" /* URL */),
            // Using TMDBLink as placeholder for kinopoiskUrl
            birthPlace: this.formatArray([fullInfo.birthPlace || ""], "short" /* SHORT_VALUE */),
            deathPlace: this.formatArray([fullInfo.deathPlace || ""], "short" /* SHORT_VALUE */),
            alsoKnownAs: this.formatArray(this.extractEnglishNamesOnly(fullInfo.alsoKnownAs || []), "short" /* SHORT_VALUE */),
            biography: this.formatArray([fullInfo.description || ""], "long" /* LONG_TEXT */),
            hometown: this.formatArray([fullInfo.hometown || fullInfo.birthPlace || ""], "short" /* SHORT_VALUE */),
            placeOfBirth: this.formatArray([fullInfo.birthPlace || ""], "short" /* SHORT_VALUE */),
            placeOfDeath: this.formatArray([fullInfo.deathPlace || ""], "short" /* SHORT_VALUE */),
            homepage: this.formatArray([fullInfo.homepage || ""], "url" /* URL */),
            knownForDepartment: this.formatArray([fullInfo.slogan || fullInfo.knownForDepartment || ""], "short" /* SHORT_VALUE */),
            popularity: ((_Z = fullInfo.rating) == null ? void 0 : _Z.tmdb) || 0,
            externalIds: this.formatArray([((__ = fullInfo.externalId) == null ? void 0 : __.imdb) || ""], "short" /* SHORT_VALUE */),
            // Combined names for aliases (to avoid duplicates between name and alsoKnownAs)
            allNames: this.combineNamesForAliases([fullInfo.name], this.extractEnglishNamesOnly(fullInfo.alsoKnownAs || []))
          } : {
            sex: this.formatArray([""], "short" /* SHORT_VALUE */),
            spouses: this.formatArray([""], "short" /* SHORT_VALUE */),
            birthday: this.formatArray([""], "short" /* SHORT_VALUE */),
            death: this.formatArray([""], "short" /* SHORT_VALUE */),
            growth: this.formatArray([""], "short" /* SHORT_VALUE */),
            kinopoiskUrl: this.formatArray([""], "url" /* URL */),
            birthPlace: this.formatArray([""], "short" /* SHORT_VALUE */),
            deathPlace: this.formatArray([""], "short" /* SHORT_VALUE */),
            alsoKnownAs: this.formatArray([], "short" /* SHORT_VALUE */),
            biography: this.formatArray([""], "long" /* LONG_TEXT */),
            hometown: this.formatArray([""], "short" /* SHORT_VALUE */),
            placeOfBirth: this.formatArray([""], "short" /* SHORT_VALUE */),
            placeOfDeath: this.formatArray([""], "short" /* SHORT_VALUE */),
            homepage: this.formatArray([""], "url" /* URL */),
            knownForDepartment: this.formatArray([""], "short" /* SHORT_VALUE */),
            popularity: 0,
            externalIds: this.formatArray([""], "short" /* SHORT_VALUE */),
            allNames: this.formatArray([fullInfo.name], "short" /* SHORT_VALUE */)
          }
        };
        if (userRating !== void 0) {
          item.userRating = userRating;
        }
        return item;
      }
      /**
       * Universal array formatting based on type
       */
      formatArray(items, formatType, folderPath, maxItems = MAX_ARRAY_ITEMS) {
        if (formatType === "link_id_with_path" /* LINK_ID_WITH_PATH */) {
          const personItems = items;
          return personItems.filter((item) => item.name && item.name.trim() !== "").slice(0, maxItems).map((item) => {
            const cleanName = this.cleanTextForMetadata(item.name);
            if (folderPath && folderPath.trim() !== "" && item.id) {
              return `"[[${folderPath}/${item.id}|${cleanName}]]"`;
            } else if (item.id) {
              return `"[[${item.id}|${cleanName}]]"`;
            }
            return `"[[${cleanName}]]"`;
          });
        }
        const stringItems = items.map(
          (item) => typeof item === "object" && item.name ? item.name : item
        );
        const filteredItems = stringItems.filter((item) => typeof item === "string" && item.trim() !== "").slice(0, maxItems);
        switch (formatType) {
          case "short" /* SHORT_VALUE */:
            return filteredItems.map(
              (item) => this.cleanTextForMetadata(item)
            );
          case "long" /* LONG_TEXT */:
            return filteredItems.map((item) => {
              const cleanedItem = item.replace(/\n/g, " ").replace(/\s+/g, " ").trim();
              return `"${cleanedItem}"`;
            });
          case "url" /* URL */:
            return filteredItems.map((item) => item.trim());
          case "link" /* LINK */:
            return filteredItems.map((item) => {
              const cleanName = this.cleanTextForMetadata(item);
              return `"[[${cleanName}]]"`;
            });
          case "link_with_path" /* LINK_WITH_PATH */:
            return filteredItems.map((item) => {
              const cleanName = this.cleanTextForMetadata(item);
              if (folderPath && folderPath.trim() !== "") {
                return `"[[${folderPath}/${cleanName}]]"`;
              }
              return `"[[${cleanName}]]"`;
            });
          default:
            return filteredItems;
        }
      }
      /**
       * Calculates seasons data from seasons info
       */
      calculateSeasonsData(seasonsInfo) {
        if (!seasonsInfo || seasonsInfo.length === 0) {
          return { count: 0, averageEpisodesPerSeason: 0 };
        }
        const totalEpisodes = seasonsInfo.reduce(
          (total, season) => total + season.episodesCount,
          0
        );
        const averageEpisodes = Math.ceil(totalEpisodes / seasonsInfo.length);
        return {
          count: seasonsInfo.length,
          averageEpisodesPerSeason: averageEpisodes
        };
      }
      /**
       * Extracts people by profession from persons array
       */
      extractPeople(persons) {
        const result = {
          directors: [],
          actors: [],
          writers: [],
          producers: []
        };
        for (const person of persons) {
          if (!person.name || !person.enProfession) continue;
          const personData = { name: person.name, id: person.id };
          switch (person.enProfession) {
            case "director":
              result.directors.push(personData);
              break;
            case "actor":
              result.actors.push(personData);
              break;
            case "writer":
              result.writers.push(personData);
              break;
            case "producer":
              result.producers.push(personData);
              break;
          }
        }
        return result;
      }
      /**
       * Extracts companies and related movies from API response
       */
      extractCompanies(fullInfo) {
        var _a, _b, _c, _d;
        const networks = ((_b = (_a = fullInfo.networks) == null ? void 0 : _a.items) == null ? void 0 : _b.map((network) => network.name).filter((name) => name && name.trim() !== "")) || [];
        const productionCompanies = ((_c = fullInfo.productionCompanies) == null ? void 0 : _c.map((company) => company.name).filter((name) => name && name.trim() !== "")) || [];
        const sequelsAndPrequels = ((_d = fullInfo.sequelsAndPrequels) == null ? void 0 : _d.map((movie) => movie.name).filter((name) => name && name.trim() !== "")) || [];
        return { networks, productionCompanies, sequelsAndPrequels };
      }
      /**
       * Processes facts by removing spoilers and HTML tags
       */
      processFacts(facts) {
        return facts.filter(
          (fact) => !fact.spoiler && fact.value && fact.value.trim() !== ""
        ).slice(0, MAX_FACTS_COUNT).map((fact) => this.stripHtmlTags(fact.value));
      }
      processNames(fullInfo) {
        var _a;
        const allNames = ((_a = fullInfo.names) == null ? void 0 : _a.map((nameObj) => nameObj.name).filter((name) => name && name.trim() !== "")) || [];
        return { allNames };
      }
      /**
       * Formats date to Obsidian format (YYYY-MM-DD)
       */
      formatDate(dateString) {
        if (!dateString) return "";
        try {
          const date = new Date(dateString);
          if (isNaN(date.getTime()) || date.getFullYear() < 1800 || date.getFullYear() > 2100) {
            return "";
          }
          return date.toISOString().split("T")[0];
        } catch (e) {
          return "";
        }
      }
      /**
       * Cleans text from characters that might break metadata
       */
      cleanTextForMetadata(text) {
        if (!text) return "";
        return text.replace(/:/g, "").trim();
      }
      /**
       * Creates image link for Obsidian format
       */
      createImageLink(imagePath) {
        if (!imagePath || imagePath.trim() === "") return [];
        if (!imagePath.startsWith("http")) {
          return [`![[${imagePath}]]`];
        }
        return [`![](${imagePath})`];
      }
      translateType(type) {
        return TYPE_TRANSLATIONS[type] || type;
      }
      /**
       * Removes HTML tags and decodes HTML entities
       */
      stripHtmlTags(text) {
        let cleanText = text.replace(/<[^>]*>/g, "");
        for (const [entity, char] of Object.entries(HTML_ENTITIES)) {
          cleanText = cleanText.replace(new RegExp(entity, "g"), char);
        }
        cleanText = cleanText.replace(/&#?\w+;/g, "");
        return cleanText.trim();
      }
      /**
       * Calculate age from birthday
       */
      calculateAge(birthday) {
        if (!birthday) return 0;
        try {
          const birthDate = new Date(birthday);
          const today = /* @__PURE__ */ new Date();
          let age = today.getFullYear() - birthDate.getFullYear();
          const monthDiff = today.getMonth() - birthDate.getMonth();
          if (monthDiff < 0 || monthDiff === 0 && today.getDate() < birthDate.getDate()) {
            age--;
          }
          return age;
        } catch (e) {
          return 0;
        }
      }
      /**
       * Extract only English names from the list of names and remove duplicates/variations
       */
      extractEnglishNamesOnly(names) {
        if (!names || !Array.isArray(names)) return [];
        const englishOnlyRegex = /^[A-Za-z\s\-\'\"\.\,\(\)]+$/;
        const englishNames = names.filter((name) => {
          return englishOnlyRegex.test(name.trim());
        });
        const uniqueNames = [];
        const processedBaseNames = [];
        for (const name of englishNames) {
          const trimmedName = name.trim();
          const baseName = trimmedName.replace(/\s+/g, " ").replace(/\b[A-Z]\.\s*/g, "").replace(/\s+/g, " ").trim();
          const isDuplicate = processedBaseNames.some((processedName) => {
            return this.areSimilarNames(baseName, processedName);
          });
          if (!isDuplicate) {
            uniqueNames.push(trimmedName);
            processedBaseNames.push(baseName);
          }
        }
        return uniqueNames;
      }
      /**
       * Check if two names are similar (one is variation of another)
       */
      areSimilarNames(name1, name2) {
        const normalizeName = (name) => {
          return name.toLowerCase().replace(/\s+/g, " ").trim();
        };
        const norm1 = normalizeName(name1);
        const norm2 = normalizeName(name2);
        return norm1.includes(norm2) || norm2.includes(norm1);
      }
      /**
       * Combine main name and also known as names, removing duplicates
       */
      combineNamesForAliases(mainNames, alsoKnownAsNames) {
        const combinedNames = [...mainNames];
        for (const name of alsoKnownAsNames) {
          if (!name) continue;
          const isDuplicate = combinedNames.some((mainName) => {
            if (!mainName) return false;
            return this.areSimilarNames(name, mainName);
          });
          if (!isDuplicate) {
            combinedNames.push(name);
          }
        }
        return combinedNames.filter((name) => name && name.trim() !== "");
      }
      /**
      *      DataFormatter
      */
      /**
       * Convert TMDB person data to TMDBFullInfo format
       */
      convertPersonToTMDBFormat(details, credits, images) {
        var _a, _b, _c, _d;
        const birthYear = details.birthday ? parseInt(details.birthday.substring(0, 4)) : 0;
        const poster = ((_a = images == null ? void 0 : images.profiles) == null ? void 0 : _a.length) > 0 ? this.extractBestImage(images.profiles, "poster") : details.profile_path ? {
          url: this.buildImageUrl(details.profile_path, TMDB_CONFIG.SIZES.POSTER_ORIGINAL),
          previewUrl: this.buildImageUrl(details.profile_path, TMDB_CONFIG.SIZES.POSTER_W500)
        } : void 0;
        const backdrop = ((_b = images == null ? void 0 : images.tagged_images) == null ? void 0 : _b.length) > 0 ? this.extractBestImage(images.tagged_images, "backdrop") : void 0;
        const knownForMovies = this.extractKnownForTitles(credits);
        const biography = details.biography || "";
        const shortBio = biography.split("\n")[0] || "";
        const department = details.known_for_department || details.knownForDepartment || "Acting";
        const profession = this.mapDepartmentToProfession(department);
        return {
          id: details.id,
          name: details.name || "",
          alternativeName: details.original_name || details.name || "",
          enName: details.original_name || details.name || "",
          type: "person",
          year: birthYear,
          description: biography,
          shortDescription: shortBio,
          poster,
          backdrop,
          logo: void 0,
          // Actors don't have logos
          genres: [],
          // Will be filled with known_for movies/shows genres
          countries: details.place_of_birth ? [{
            name: this.extractCountryFromBirthPlace(details.place_of_birth)
          }] : [],
          persons: [],
          // Empty for actors themselves
          movieLength: 0,
          isSeries: false,
          TMDBLink: `https://www.themoviedb.org/person/${details.id}`,
          rating: {
            tmdb: details.popularity || 0,
            imdb: 0
          },
          votes: {
            tmdb: 0,
            imdb: 0
          },
          externalId: {
            imdb: details.imdb_id || ((_c = details.external_ids) == null ? void 0 : _c.imdb_id),
            tmdb: details.id
          },
          slogan: department,
          // Use department as slogan
          premiere: {
            world: details.birthday
            // Birth date as premiere
          },
          deathday: details.deathday || "",
          // Add death day
          gender: details.gender,
          // Add gender information
          ageRating: 0,
          ratingMpaa: "",
          productionCompanies: [],
          // Empty for actors
          networks: void 0,
          names: ((_d = details.also_known_as) == null ? void 0 : _d.map((name) => ({
            name,
            type: "alternative"
          }))) || [],
          sequelsAndPrequels: knownForMovies,
          // Additional actor-specific fields based on API structure
          birthPlace: details.place_of_birth || "",
          // Place of birth
          deathPlace: details.death_place || "",
          // Place of death (if available)
          alsoKnownAs: this.extractEnglishNamesOnly(details.also_known_as || []),
          // Only English names from also known as
          hometown: details.hometown || details.place_of_birth || "",
          // Hometown or birthplace
          homepage: details.homepage || details.homepage || "",
          // Homepage if available
          knownForDepartment: details.known_for_department || details.knownForDepartment || ""
          // Known for department
        };
      }
      /**
       * Extract country from birth place string
       */
      extractCountryFromBirthPlace(birthPlace) {
        const parts = birthPlace.split(",").map((p) => p.trim());
        return parts[parts.length - 1] || birthPlace;
      }
      /**
       * Map TMDB department to profession
       */
      mapDepartmentToProfession(department) {
        const professionMap = {
          "Acting": "\u0410\u043A\u0442\u0451\u0440",
          "Directing": "\u0420\u0435\u0436\u0438\u0441\u0441\u0451\u0440",
          "Writing": "\u0421\u0446\u0435\u043D\u0430\u0440\u0438\u0441\u0442",
          "Production": "\u041F\u0440\u043E\u0434\u044E\u0441\u0435\u0440",
          "Camera": "\u041E\u043F\u0435\u0440\u0430\u0442\u043E\u0440",
          "Editing": "\u041C\u043E\u043D\u0442\u0430\u0436\u0451\u0440",
          "Sound": "\u0417\u0432\u0443\u043A\u043E\u0440\u0435\u0436\u0438\u0441\u0441\u0451\u0440",
          "Art": "\u0425\u0443\u0434\u043E\u0436\u043D\u0438\u043A",
          "Costume & Make-Up": "\u041A\u043E\u0441\u0442\u044E\u043C\u0435\u0440"
        };
        return professionMap[department] || department;
      }
      /**
       * Extract top known for movies/shows from credits
       */
      extractKnownForTitles(credits) {
        if (!credits) return [];
        const allCredits = [
          ...credits.cast || [],
          ...credits.crew || []
        ];
        const sortedCredits = allCredits.sort((a, b) => {
          const scoreA = (a.popularity || 0) + (a.vote_count || 0) * 0.1;
          const scoreB = (b.popularity || 0) + (b.vote_count || 0) * 0.1;
          return scoreB - scoreA;
        }).slice(0, 10);
        return sortedCredits.map((item) => ({
          id: item.id,
          name: item.title || item.name || "",
          alternativeName: item.original_title || item.original_name || "",
          enName: item.original_title || item.original_name || "",
          type: item.media_type || "movie",
          poster: item.poster_path ? {
            url: this.buildImageUrl(item.poster_path, TMDB_CONFIG.SIZES.POSTER_ORIGINAL),
            previewUrl: this.buildImageUrl(item.poster_path, TMDB_CONFIG.SIZES.POSTER_W500)
          } : void 0,
          rating: {
            tmdb: item.vote_average || 0,
            imdb: 0
          },
          year: item.release_date || item.first_air_date ? parseInt((item.release_date || item.first_air_date).substring(0, 4)) : 0
        }));
      }
    };
  }
});

// APIProvider/ApiValidator.ts
var MIN_QUERY_LENGTH, MAX_QUERY_LENGTH, MIN_TOKEN_LENGTH, MAX_TOKEN_LENGTH, MIN_MOVIE_ID, MAX_MOVIE_ID, ApiValidator;
var init_ApiValidator = __esm({
  "APIProvider/ApiValidator.ts"() {
    init_i18n();
    MIN_QUERY_LENGTH = 1;
    MAX_QUERY_LENGTH = 200;
    MIN_TOKEN_LENGTH = 20;
    MAX_TOKEN_LENGTH = 500;
    MIN_MOVIE_ID = 1;
    MAX_MOVIE_ID = 99999999;
    ApiValidator = class {
      /**
       * Validates API token format and length for TMDB
       */
      isValidToken(token) {
        if (typeof token !== "string") {
          return false;
        }
        const trimmedToken = token.trim();
        if (!trimmedToken) {
          return false;
        }
        if (trimmedToken.length < MIN_TOKEN_LENGTH || trimmedToken.length > MAX_TOKEN_LENGTH) {
          return false;
        }
        const tokenPattern = /^[A-Za-z0-9\-_\.]+$/;
        if (!tokenPattern.test(trimmedToken)) {
          return false;
        }
        return true;
      }
      /**
       * Validates search query for safety and length
       */
      isValidSearchQuery(query) {
        if (typeof query !== "string") {
          return false;
        }
        const trimmedQuery = query.trim();
        if (!trimmedQuery) {
          return false;
        }
        if (trimmedQuery.length < MIN_QUERY_LENGTH || trimmedQuery.length > MAX_QUERY_LENGTH) {
          return false;
        }
        const suspiciousPatterns = [
          /<script/i,
          /javascript:/i,
          /on\w+=/i,
          /<%/,
          /%>/
        ];
        if (suspiciousPatterns.some((pattern) => pattern.test(trimmedQuery))) {
          return false;
        }
        return true;
      }
      /**
       * Validates movie ID range and type
       */
      isValidMovieId(id) {
        if (typeof id !== "number") {
          return false;
        }
        if (!Number.isFinite(id)) {
          return false;
        }
        if (id < MIN_MOVIE_ID || id > MAX_MOVIE_ID) {
          return false;
        }
        if (!Number.isInteger(id)) {
          return false;
        }
        return true;
      }
      /**
       * Validates pagination parameters
       */
      isValidPaginationParams(page, limit) {
        if (page !== void 0) {
          if (!Number.isInteger(page) || page < 1 || page > 1e3) {
            return false;
          }
        }
        if (limit !== void 0) {
          if (!Number.isInteger(limit) || limit < 1 || limit > 250) {
            return false;
          }
        }
        return true;
      }
      /**
       * Sanitizes search query by removing dangerous characters
       */
      sanitizeQuery(query) {
        return query.trim().replace(/\s+/g, " ").replace(/[<>]/g, "").substring(0, MAX_QUERY_LENGTH);
      }
      /**
       * Sanitizes token by keeping only allowed characters
       */
      sanitizeToken(token) {
        return token.trim().replace(/[^A-Za-z0-9\-_\.]/g, "").substring(0, MAX_TOKEN_LENGTH);
      }
      /**
       * Validates complete request configuration
       */
      validateRequestConfig(config) {
        const errors = [];
        if (!this.isValidToken(config.token)) {
          errors.push(t("validation.invalidApiToken"));
        }
        if (config.query !== void 0 && !this.isValidSearchQuery(config.query)) {
          errors.push(t("validation.invalidSearchQuery"));
        }
        if (config.movieId !== void 0 && !this.isValidMovieId(config.movieId)) {
          errors.push(t("validation.invalidMovieId"));
        }
        if (!this.isValidPaginationParams(config.page, config.limit)) {
          errors.push(t("validation.invalidPaginationParams"));
        }
        return {
          isValid: errors.length === 0,
          errors
        };
      }
    };
  }
});

// APIProvider/provider.ts
var provider_exports = {};
__export(provider_exports, {
  TMDBProvider: () => TMDBProvider,
  getByQuery: () => getByQuery,
  getMovieShowById: () => getMovieShowById,
  validateApiToken: () => validateApiToken
});
async function getByQuery(query, token) {
  return provider.searchByQuery(query, token);
}
async function getMovieShowById(id, token) {
  return provider.getMovieById(id, token);
}
async function validateApiToken(token) {
  return provider.validateToken(token);
}
var import_obsidian2, API_BASE_URL, MAX_SEARCH_RESULTS, LANGUAGE, IMAGE_BASE_URL, TMDBProvider, provider;
var init_provider = __esm({
  "APIProvider/provider.ts"() {
    import_obsidian2 = require("obsidian");
    init_ErrorHandler();
    init_DataFormatter();
    init_ApiValidator();
    init_i18n();
    API_BASE_URL = "https://api.themoviedb.org/3";
    MAX_SEARCH_RESULTS = 20;
    LANGUAGE = "ru-RU";
    IMAGE_BASE_URL = "https://image.tmdb.org/t/p/";
    TMDBProvider = class {
      constructor(settings) {
        this.errorHandler = new ErrorHandler();
        this.dataFormatter = new DataFormatter();
        this.validator = new ApiValidator();
        if (settings) {
          this.dataFormatter.setSettings(settings);
        }
      }
      /**
       * Performs HTTP GET request to TMDB API
       */
      async apiGet(endpoint, token, params = {}) {
        if (!this.validator.isValidToken(token)) {
          throw new Error(t("provider.tokenRequired"));
        }
        params.language = LANGUAGE;
        const url = this.buildUrl(endpoint, params);
        try {
          const res = await (0, import_obsidian2.requestUrl)({
            url,
            method: "GET",
            headers: {
              accept: "application/json",
              Authorization: "Bearer " + token
            }
          });
          return res.json;
        } catch (error) {
          throw this.errorHandler.handleApiError(error);
        }
      }
      /**
       * Builds URL with query parameters
       */
      buildUrl(endpoint, params) {
        const url = new URL(`${API_BASE_URL}${endpoint}`);
        for (const [key, value] of Object.entries(params)) {
          if (value !== void 0 && value !== null && value !== "") {
            url.searchParams.set(key, value.toString());
          }
        }
        return url.href;
      }
      /**
       * Calculate relevance score for actor search result
       */
      calculateRelevanceScore(item, query) {
        const normalizedQuery = query.toLowerCase().trim();
        const name = (item.name || "").toLowerCase();
        let score = 0;
        if (name === normalizedQuery) {
          score += 1e3;
        }
        if (name.startsWith(normalizedQuery)) {
          score += 500;
        }
        if (name.includes(normalizedQuery)) {
          score += 250;
        }
        score += (item.popularity || 0) * 2;
        return score;
      }
      /**
       * Search for actors/people by query
       */
      async searchByQuery(query, token) {
        if (!this.validator.isValidSearchQuery(query)) {
          throw new Error(t("provider.enterMovieTitle"));
        }
        const response = await this.apiGet(
          "/search/person",
          token,
          {
            query: query.trim(),
            page: 1
          }
        );
        const results = (response.results || []).map((item) => ({
          item: this.convertToSuggestItem(item),
          score: this.calculateRelevanceScore(item, query)
        })).sort((a, b) => b.score - a.score).map((entry) => entry.item).slice(0, MAX_SEARCH_RESULTS);
        if (results.length === 0) {
          throw new Error(
            tWithParams("provider.nothingFound", { query }) + " " + t("provider.tryChangeQuery")
          );
        }
        return results;
      }
      /**
       * Get all available images for a person
       */
      async getAllImages(id, token, type) {
        try {
          const endpoint = `/person/${id}/images`;
          const images = await this.apiGet(endpoint, token, {});
          const extractImageData = (imageArray = []) => {
            return imageArray.map((img) => ({
              url: `${IMAGE_BASE_URL}original${img.file_path}`,
              language: img.iso_639_1 || void 0
            })).filter((img) => img.url && img.url.trim() !== "");
          };
          return {
            posters: extractImageData(images.profiles || []),
            backdrops: extractImageData(images.tagged_images || []),
            logos: []
            // Actors don't have logos
          };
        } catch (error) {
          console.error("Error fetching all images:", error);
          return { posters: [], backdrops: [], logos: [] };
        }
      }
      /**
       * Convert TMDB person search result to TMDBSuggestItem format
       */
      convertToSuggestItem(item) {
        const name = item.name || "";
        const knownFor = item.known_for_department || "Acting";
        return {
          id: item.id,
          name,
          alternativeName: knownFor,
          // Use profession instead of alt name
          type: "person",
          year: 0,
          // Actors don't have a year
          poster: item.profile_path ? {
            url: `${IMAGE_BASE_URL}w500${item.profile_path}`,
            previewUrl: `${IMAGE_BASE_URL}w185${item.profile_path}`
          } : void 0,
          rating: {
            tmdb: item.popularity || 0,
            imdb: 0
          }
        };
      }
      /**
       * Retrieves detailed person information by ID
       */
      async getMovieById(id, token, type, userRating) {
        if (!this.validator.isValidMovieId(id)) {
          throw new Error(t("provider.invalidMovieId"));
        }
        if (!this.validator.isValidToken(token)) {
          throw new Error(t("provider.tokenRequiredForMovie"));
        }
        const personData = await this.getPersonDetails(id, token);
        return this.dataFormatter.createMovieShowFrom(personData, userRating);
      }
      /**
       * Get person details from TMDB
       */
      async getPersonDetails(id, token) {
        const [details, credits, images] = await Promise.all([
          this.apiGet(`/person/${id}`, token, {
            append_to_response: "external_ids,translations"
          }),
          this.apiGet(`/person/${id}/combined_credits`, token, {}),
          this.apiGet(`/person/${id}/images`, token, {})
        ]);
        return this.dataFormatter.convertPersonToTMDBFormat(details, credits, images);
      }
      /**
       * Validates API token by making test request
       */
      async validateToken(token) {
        if (!this.validator.isValidToken(token)) {
          return false;
        }
        try {
          await this.apiGet("/configuration", token, {});
          return true;
        } catch (e) {
          return false;
        }
      }
    };
    provider = new TMDBProvider();
  }
});

// Utils/imageUtils.ts
var imageUtils_exports = {};
__export(imageUtils_exports, {
  downloadAndSaveImage: () => downloadAndSaveImage,
  processImages: () => processImages
});
function isValidImageUrl(url) {
  if (!url || url.trim() === "") return false;
  try {
    new URL(url);
    return url.startsWith("http://") || url.startsWith("https://");
  } catch (e) {
    return false;
  }
}
function getImageExtension(url, mimeType) {
  var _a;
  if (mimeType && MIME_TO_EXTENSION_MAP[mimeType]) {
    return MIME_TO_EXTENSION_MAP[mimeType];
  }
  const urlExtension = (_a = url.split(".").pop()) == null ? void 0 : _a.toLowerCase();
  if (urlExtension && SUPPORTED_EXTENSIONS.includes(urlExtension)) {
    return urlExtension;
  }
  return "jpg";
}
function createImageFileName(movieShow, imageType, extension, settings) {
  const itemType = Array.isArray(movieShow.type) ? movieShow.type[0] : movieShow.type;
  const isActor = itemType === "person" || itemType === "\u041F\u0435\u0440\u0441\u043E\u043D\u0430" || itemType.toLowerCase().includes("person");
  let fileNameFormat = `${movieShow.id}_${imageType}`;
  if (isActor && settings.actorImageFileNameFormat) {
    fileNameFormat = settings.actorImageFileNameFormat;
    const nameForFile = Array.isArray(movieShow.nameForFile) ? movieShow.nameForFile[0] || movieShow.id.toString() : movieShow.nameForFile || movieShow.name || movieShow.id.toString();
    const enNameForFile = Array.isArray(movieShow.enNameForFile) ? movieShow.enNameForFile[0] || nameForFile : movieShow.enNameForFile || movieShow.enName || nameForFile;
    fileNameFormat = fileNameFormat.replace(/{{id}}/g, movieShow.id.toString()).replace(/{{nameForFile}}/g, nameForFile).replace(/{{enNameForFile}}/g, enNameForFile);
    fileNameFormat = `${fileNameFormat}_${imageType}`;
  }
  const cleanedBaseName = replaceIllegalFileNameCharactersInString(fileNameFormat);
  return `${cleanedBaseName}.${extension}`;
}
function extractCleanPath(imagePath) {
  if (!imagePath || imagePath.trim() === "") return "";
  if (!imagePath.startsWith("http")) {
    return imagePath.split("/").pop() || imagePath;
  }
  return imagePath;
}
function isNetworkError(error) {
  if (!error || typeof error !== "object" || typeof error.message !== "string") {
    return false;
  }
  const networkErrors = [
    "ERR_CONNECTION_TIMED_OUT",
    "ERR_NETWORK_CHANGED",
    "ERR_INTERNET_DISCONNECTED",
    "ERR_NAME_NOT_RESOLVED",
    "ERR_CONNECTION_REFUSED",
    "ERR_CONNECTION_RESET",
    "ERR_BLOCKED_BY_CLIENT"
  ];
  return networkErrors.some(
    (errorCode) => error.message.includes(errorCode)
  );
}
function withTimeout(promise, timeoutMs) {
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(
        new Error(tWithParams("images.timeout", { timeout: timeoutMs }))
      );
    }, timeoutMs);
  });
  return Promise.race([promise, timeoutPromise]);
}
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function downloadImage(url) {
  if (!isValidImageUrl(url)) {
    throw new Error(tWithParams("images.invalidUrl", { url }));
  }
  let lastError = new Error(
    tWithParams("images.downloadFailed", { url })
  );
  for (let attempt = 1; attempt <= DOWNLOAD_CONFIG.maxRetries; attempt++) {
    try {
      const downloadPromise = (0, import_obsidian4.requestUrl)({
        url,
        method: "GET"
      });
      const response = await withTimeout(
        downloadPromise,
        DOWNLOAD_CONFIG.timeout
      );
      if (response.status !== 200) {
        if (response.status === 404) {
          throw new Error(
            tWithParams("images.imageNotFound", { url })
          );
        } else if (response.status === 403) {
          throw new Error(
            tWithParams("images.accessForbidden", { url })
          );
        } else if (response.status >= 500) {
          throw new Error(
            tWithParams("images.serverError", {
              status: response.status,
              url
            })
          );
        } else {
          throw new Error(
            tWithParams("images.httpError", {
              status: response.status,
              url
            })
          );
        }
      }
      return {
        data: response.arrayBuffer,
        mimeType: response.headers["content-type"]
      };
    } catch (error) {
      lastError = error;
      console.warn(
        `Failed to download image (attempt ${attempt}/${DOWNLOAD_CONFIG.maxRetries}): ${url}`,
        error
      );
      if (attempt === DOWNLOAD_CONFIG.maxRetries || !isNetworkError(error)) {
        break;
      }
      if (attempt < DOWNLOAD_CONFIG.maxRetries) {
        await delay(DOWNLOAD_CONFIG.retryDelay);
      }
    }
  }
  console.error(
    `Failed to download image after ${DOWNLOAD_CONFIG.maxRetries} attempts: ${url}`,
    lastError
  );
  throw lastError;
}
async function saveImageToVault(app, imageData, folderPath, fileName) {
  const { vault } = app;
  const normalizedFolderPath = (0, import_obsidian4.normalizePath)(folderPath);
  if (!vault.getAbstractFileByPath(normalizedFolderPath)) {
    await vault.createFolder(normalizedFolderPath);
  }
  const fullPath = (0, import_obsidian4.normalizePath)(`${folderPath}/${fileName}`);
  let finalPath = fullPath;
  let counter = 1;
  while (vault.getAbstractFileByPath(finalPath)) {
    const pathParts = fullPath.split(".");
    const extension = pathParts.pop();
    const basePath = pathParts.join(".");
    finalPath = `${basePath}_${counter}.${extension}`;
    counter++;
  }
  await vault.createBinary(finalPath, imageData);
  return finalPath;
}
async function downloadAndSaveImage(app, url, movieShow, imageType, folderPath, settings) {
  try {
    if (!isValidImageUrl(url)) {
      return url;
    }
    const { data, mimeType } = await downloadImage(url);
    const extension = getImageExtension(url, mimeType);
    const fileName = createImageFileName(movieShow, imageType, extension, settings);
    const localPath = await saveImageToVault(
      app,
      data,
      folderPath,
      fileName
    );
    return localPath;
  } catch (error) {
    console.error(`Failed to download and save image: ${url}`, error);
    throw error;
  }
}
function createImageLink(imagePath) {
  if (!imagePath || imagePath.trim() === "") return [];
  if (!imagePath.startsWith("http")) {
    const fileName = imagePath.split("/").pop() || imagePath;
    return [`![[${fileName}]]`];
  }
  return [`![](${imagePath})`];
}
function countImagesToDownload(movieShow, settings) {
  let count = 0;
  if (settings.savePosterImage && movieShow.posterUrl.length > 0 && movieShow.posterUrl[0] && isValidImageUrl(movieShow.posterUrl[0])) {
    count++;
  }
  if (settings.saveCoverImage && movieShow.coverUrl.length > 0 && movieShow.coverUrl[0] && isValidImageUrl(movieShow.coverUrl[0])) {
    count++;
  }
  if (settings.saveLogoImage && movieShow.logoUrl.length > 0 && movieShow.logoUrl[0] && isValidImageUrl(movieShow.logoUrl[0])) {
    count++;
  }
  return count;
}
function getImageTypeDisplayName(imageType) {
  return t(`images.${imageType}`);
}
async function processImages(app, movieShow, settings, progressCallback) {
  if (!settings.saveImagesLocally) {
    return movieShow;
  }
  const updatedMovieShow = { ...movieShow };
  const totalImages = countImagesToDownload(movieShow, settings);
  let processedImages = 0;
  let successfulDownloads = 0;
  let failedDownloads = 0;
  if (totalImages === 0) {
    progressCallback == null ? void 0 : progressCallback(0, 0, t("images.noImagesToDownload"));
    return movieShow;
  }
  try {
    if (settings.savePosterImage && movieShow.posterUrl.length > 0 && movieShow.posterUrl[0]) {
      const posterUrl = movieShow.posterUrl[0];
      if (isValidImageUrl(posterUrl)) {
        const imageTypeName = getImageTypeDisplayName("poster");
        progressCallback == null ? void 0 : progressCallback(
          processedImages + 1,
          totalImages,
          `${t("images.downloading")} ${imageTypeName}...`
        );
        try {
          const localPath = await downloadAndSaveImage(
            app,
            posterUrl,
            movieShow,
            "poster",
            settings.imagesFolder,
            settings
          );
          updatedMovieShow.posterMarkdown = createImageLink(localPath);
          updatedMovieShow.posterPath = [extractCleanPath(localPath)];
          processedImages++;
          successfulDownloads++;
        } catch (error) {
          console.warn("Failed to download poster image:", error);
          processedImages++;
          failedDownloads++;
          if (isNetworkError(error)) {
            console.warn(t("images.posterUnavailable"));
          } else {
            console.warn(
              `${t("images.downloadError")} ${t("images.poster")}`
            );
          }
          updatedMovieShow.posterMarkdown = createImageLink(posterUrl);
          updatedMovieShow.posterPath = [extractCleanPath(posterUrl)];
        }
      } else {
        updatedMovieShow.posterMarkdown = createImageLink(posterUrl);
        updatedMovieShow.posterPath = [extractCleanPath(posterUrl)];
      }
    }
    if (settings.saveCoverImage && movieShow.coverUrl.length > 0 && movieShow.coverUrl[0]) {
      const coverUrl = movieShow.coverUrl[0];
      if (isValidImageUrl(coverUrl)) {
        const imageTypeName = getImageTypeDisplayName("cover");
        progressCallback == null ? void 0 : progressCallback(
          processedImages + 1,
          totalImages,
          `${t("images.downloading")} ${imageTypeName}...`
        );
        try {
          const localPath = await downloadAndSaveImage(
            app,
            coverUrl,
            movieShow,
            "cover",
            settings.imagesFolder,
            settings
          );
          updatedMovieShow.coverMarkdown = createImageLink(localPath);
          updatedMovieShow.coverPath = [extractCleanPath(localPath)];
          processedImages++;
          successfulDownloads++;
        } catch (error) {
          console.warn("Failed to download cover image:", error);
          processedImages++;
          failedDownloads++;
          if (isNetworkError(error)) {
            console.warn(t("images.coverUnavailable"));
          } else {
            console.warn(
              `${t("images.downloadError")} ${t("images.cover")}`
            );
          }
          updatedMovieShow.coverMarkdown = createImageLink(coverUrl);
          updatedMovieShow.coverPath = [extractCleanPath(coverUrl)];
        }
      } else {
        updatedMovieShow.coverMarkdown = createImageLink(coverUrl);
        updatedMovieShow.coverPath = [extractCleanPath(coverUrl)];
      }
    }
    if (settings.saveLogoImage && movieShow.logoUrl.length > 0 && movieShow.logoUrl[0]) {
      const logoUrl = movieShow.logoUrl[0];
      if (isValidImageUrl(logoUrl)) {
        const imageTypeName = getImageTypeDisplayName("logo");
        progressCallback == null ? void 0 : progressCallback(
          processedImages + 1,
          totalImages,
          `${t("images.downloading")} ${imageTypeName}...`
        );
        try {
          const localPath = await downloadAndSaveImage(
            app,
            logoUrl,
            movieShow,
            "logo",
            settings.imagesFolder,
            settings
          );
          updatedMovieShow.logoMarkdown = createImageLink(localPath);
          updatedMovieShow.logoPath = [extractCleanPath(localPath)];
          processedImages++;
          successfulDownloads++;
        } catch (error) {
          console.warn("Failed to download logo image:", error);
          processedImages++;
          failedDownloads++;
          if (isNetworkError(error)) {
            console.warn(t("images.logoUnavailable"));
          } else {
            console.warn(
              `${t("images.downloadError")} ${t("images.logo")}`
            );
          }
          updatedMovieShow.logoMarkdown = createImageLink(logoUrl);
          updatedMovieShow.logoPath = [extractCleanPath(logoUrl)];
        }
      } else {
        updatedMovieShow.logoMarkdown = createImageLink(logoUrl);
        updatedMovieShow.logoPath = [extractCleanPath(logoUrl)];
      }
    }
    if (progressCallback) {
      if (failedDownloads > 0) {
        progressCallback(
          totalImages,
          totalImages,
          tWithParams("images.completedWithErrors", {
            successful: successfulDownloads,
            failed: failedDownloads
          })
        );
      } else if (successfulDownloads > 0) {
        progressCallback(
          totalImages,
          totalImages,
          t("images.completedAllDownloaded")
        );
      } else {
        progressCallback(
          totalImages,
          totalImages,
          t("images.completedAlreadyLocal")
        );
      }
    }
    if (failedDownloads > 0) {
      if (successfulDownloads > 0) {
        new import_obsidian4.Notice(
          tWithParams("images.downloadedWithErrors", {
            successful: successfulDownloads,
            total: totalImages
          })
        );
      } else {
        new import_obsidian4.Notice(t("images.imagesUnavailable"));
      }
    }
  } catch (error) {
    console.error("Error processing images:", error);
    progressCallback == null ? void 0 : progressCallback(
      processedImages,
      totalImages,
      t("images.processingError")
    );
    new import_obsidian4.Notice(t("images.processingError"));
  }
  return updatedMovieShow;
}
var import_obsidian4, DOWNLOAD_CONFIG, SUPPORTED_EXTENSIONS, MIME_TO_EXTENSION_MAP;
var init_imageUtils = __esm({
  "Utils/imageUtils.ts"() {
    import_obsidian4 = require("obsidian");
    init_utils();
    init_i18n();
    DOWNLOAD_CONFIG = {
      timeout: 1e4,
      // 10 seconds timeout
      maxRetries: 2,
      // maximum 2 attempts
      retryDelay: 1e3
      // delay between attempts in ms
    };
    SUPPORTED_EXTENSIONS = [
      "jpg",
      "jpeg",
      "png",
      "gif",
      "webp",
      "svg",
      "bmp"
    ];
    MIME_TO_EXTENSION_MAP = {
      "image/jpeg": "jpg",
      "image/jpg": "jpg",
      "image/png": "png",
      "image/gif": "gif",
      "image/webp": "webp",
      "image/svg+xml": "svg",
      "image/bmp": "bmp"
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianTMDBPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// Views/search_modal.ts
var import_obsidian3 = require("obsidian");
init_provider();
init_i18n();
var SearchModal = class extends import_obsidian3.Modal {
  constructor(plugin, callback) {
    super(plugin.app);
    this.callback = callback;
    this.isBusy = false;
    this.query = "";
    this.token = "";
    // Enter key handler for search
    this.submitEnterCallback = (event) => {
      if (event.key === "Enter" && !event.isComposing) {
        this.search();
      }
    };
    this.token = plugin.settings.apiToken;
    this.TMDBProvider = new TMDBProvider({
      actorsPath: plugin.settings.actorsPath,
      directorsPath: plugin.settings.directorsPath,
      writersPath: plugin.settings.writersPath,
      producersPath: plugin.settings.producersPath
    });
  }
  // Manages UI loading state
  setBusy(busy) {
    var _a, _b, _c;
    this.isBusy = busy;
    (_a = this.okBtnRef) == null ? void 0 : _a.setDisabled(busy);
    (_b = this.okBtnRef) == null ? void 0 : _b.setButtonText(
      busy ? t("modals.searching") : t("modals.searchButton")
    );
    (_c = this.inputRef) == null ? void 0 : _c.setDisabled(busy);
  }
  // Validates input before search
  validateInput() {
    var _a, _b;
    if (!((_a = this.query) == null ? void 0 : _a.trim())) {
      new import_obsidian3.Notice(t("modals.enterMovieName"));
      return false;
    }
    if (!((_b = this.token) == null ? void 0 : _b.trim())) {
      new import_obsidian3.Notice(t("modals.needApiToken"));
      return false;
    }
    if (this.isBusy) {
      return false;
    }
    return true;
  }
  // Handles search errors
  handleSearchError(error) {
    const errorMessage = error instanceof Error ? error.message : t("modals.errorUnexpected");
    new import_obsidian3.Notice(errorMessage);
    this.callback(error);
  }
  // Performs search via TMDB API
  async search() {
    if (!this.validateInput()) {
      return;
    }
    try {
      this.setBusy(true);
      const searchResults = await this.TMDBProvider.searchByQuery(
        this.query.trim(),
        this.token
      );
      this.callback(null, searchResults);
      this.close();
    } catch (error) {
      this.handleSearchError(error);
    } finally {
      this.setBusy(false);
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: t("modals.searchTitle") });
    contentEl.createDiv(
      { cls: "TMDB-plugin__search-modal--input" },
      (settingItem) => {
        this.inputRef = new import_obsidian3.TextComponent(settingItem).setValue(this.query).setPlaceholder(t("modals.searchPlaceholder")).onChange((value) => this.query = value);
        this.inputRef.inputEl.addEventListener(
          "keydown",
          this.submitEnterCallback
        );
      }
    );
    new import_obsidian3.Setting(contentEl).addButton((btn) => {
      return this.okBtnRef = btn.setButtonText(t("modals.searchButton")).setCta().onClick(() => {
        this.search();
      });
    });
  }
  onClose() {
    var _a;
    if ((_a = this.inputRef) == null ? void 0 : _a.inputEl) {
      this.inputRef.inputEl.removeEventListener(
        "keydown",
        this.submitEnterCallback
      );
    }
    this.contentEl.empty();
  }
};

// Views/suggest_modal.ts
var import_obsidian7 = require("obsidian");
init_provider();
init_imageUtils();

// Views/image_selection_modal.ts
var import_obsidian5 = require("obsidian");
var ImageApprovalModal = class extends import_obsidian5.Modal {
  constructor(app, data, onConfirm) {
    super(app);
    this.data = data;
    this.onConfirm = onConfirm;
    this.isListView = false;
    this.activeViewType = "poster";
  }
  sortImages(images) {
    const getLangPriority = (lang) => {
      if (lang === "ru") return 1;
      if (lang === "en") return 2;
      return 3;
    };
    return [...images].sort((a, b) => {
      const priorityA = getLangPriority(a.language);
      const priorityB = getLangPriority(b.language);
      return priorityA - priorityB;
    });
  }
  render() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("TMDB-plugin__image-approval-modal");
    if (this.isListView) {
      this.renderListView();
    } else {
      this.renderSummaryView();
    }
  }
  // ---  1:  ( ) ---
  renderSummaryView() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "\u041E\u0440\u0438\u0433\u0438\u043D\u0430\u043B\u044C\u043D\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F" });
    const scrollContainer = contentEl.createDiv({ cls: "TMDB-plugin__summary-scroll" });
    const posterInfo = this.data.poster.all.find((img) => img.url === this.data.poster.current);
    const coverInfo = this.data.cover.all.find((img) => img.url === this.data.cover.current);
    const logoInfo = this.data.logo.all.find((img) => img.url === this.data.logo.current);
    this.createSummarySection(scrollContainer, "\u041F\u043E\u0441\u0442\u0435\u0440", this.data.poster.current, "poster", posterInfo == null ? void 0 : posterInfo.language);
    const footer = contentEl.createDiv({ cls: "TMDB-plugin__button-container" });
    const setting = new import_obsidian5.Setting(footer);
    setting.addButton(
      (btn) => btn.setButtonText("\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C").setCta().onClick(() => {
        this.onConfirm({
          poster: this.data.poster.current,
          cover: this.data.cover.current,
          logo: this.data.logo.current
        });
        this.close();
      })
    );
  }
  createSummarySection(parent, title, url, type, language) {
    const card = parent.createDiv({ cls: "TMDB-plugin__summary-section" });
    const header = card.createDiv({ cls: "TMDB-plugin__summary-header" });
    header.createEl("h3", { text: title });
    const imgFrame = card.createDiv({ cls: `TMDB-plugin__summary-image-frame is-${type}` });
    if (url) {
      if (language) {
        imgFrame.createDiv({
          cls: "TMDB-plugin__language-badge",
          text: language.toUpperCase()
        });
      }
      const img = imgFrame.createEl("img");
      img.src = url;
      if (type === "logo") img.addClass("is-contain");
    } else {
      imgFrame.addClass("is-empty");
      imgFrame.createDiv({ text: "\u041D\u0435\u0442 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F", cls: "empty-text" });
    }
    const actionContainer = card.createDiv({ cls: "TMDB-plugin__summary-actions" });
    new import_obsidian5.Setting(actionContainer).addButton(
      (btn) => btn.setButtonText("\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C").setClass("mod-ghost").onClick(() => {
        this.backupData = JSON.parse(JSON.stringify(this.data));
        this.activeViewType = type;
        this.isListView = true;
        this.render();
      })
    );
  }
  renderListView() {
    const { contentEl } = this;
    const currentType = this.activeViewType;
    const listData = this.data[currentType];
    contentEl.empty();
    const headerDiv = contentEl.createDiv({ cls: "TMDB-plugin__list-header" });
    const titles = {
      "poster": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u041F\u043E\u0441\u0442\u0435\u0440",
      "cover": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u041E\u0431\u043B\u043E\u0436\u043A\u0443",
      "logo": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u041B\u043E\u0433\u043E\u0442\u0438\u043F"
    };
    headerDiv.createEl("h2", { text: titles[currentType] || currentType });
    const gridContainer = contentEl.createDiv({ cls: "TMDB-plugin__images-grid" });
    gridContainer.addClass(`is-${currentType}`);
    const sortedImages = this.sortImages(listData.all);
    sortedImages.forEach((imageInfo) => {
      const { url, language } = imageInfo;
      const imgWrapper = gridContainer.createDiv({
        cls: `TMDB-plugin__grid-item ${url === listData.current ? "is-selected" : ""}`
      });
      if (language) {
        imgWrapper.createDiv({
          cls: "TMDB-plugin__language-badge",
          text: language.toUpperCase()
        });
      }
      const img = imgWrapper.createEl("img");
      img.src = url;
      imgWrapper.addEventListener("click", () => {
        this.data[currentType].current = url;
        this.isListView = false;
        this.activeViewType = "poster";
        this.render();
      });
    });
    const footer = contentEl.createDiv({ cls: "TMDB-plugin__button-container" });
    new import_obsidian5.Setting(footer).addButton((btn) => btn.setButtonText("\u041D\u0430\u0437\u0430\u0434 \u043A \u0441\u0432\u043E\u0434\u043A\u0435").onClick(() => {
      if (this.backupData) {
        this.data[currentType].current = this.backupData[currentType].current;
      }
      this.isListView = false;
      this.render();
    }));
  }
  onOpen() {
    this.render();
  }
};

// Views/status_selection_modal.ts
var import_obsidian6 = require("obsidian");
init_i18n();
var StatusSelectionModal = class extends import_obsidian6.Modal {
  constructor(app, statusOptions, onChooseStatus) {
    super(app);
    this.statusOptions = statusOptions;
    this.selectedStatus = null;
    this.onChooseStatus = onChooseStatus;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("TMDB-plugin__status-selection-modal");
    contentEl.createEl("h2", { text: t("status.selectStatus") });
    const optionsContainer = contentEl.createDiv({ cls: "status-options-container" });
    this.statusOptions.forEach((status) => {
      const statusEmojis = {
        [t("status.willWatch")]: "\u{1F3AC}",
        [t("status.haveWatched")]: "\u2705",
        [t("status.watching")]: "\u{1F4FA}",
        [t("status.dropped")]: "\u23F8\uFE0F"
      };
      const emoji = statusEmojis[status] || "\u2B50";
      const displayName = `${emoji} ${status}`;
      const setting = new import_obsidian6.Setting(optionsContainer).setName(displayName);
      setting.settingEl.style.cursor = "pointer";
      setting.settingEl.onclick = () => {
        this.selectedStatus = status;
        this.close();
      };
    });
    const skipSetting = new import_obsidian6.Setting(contentEl).setName(t("status.skip")).setDesc(`${t("status.useDefault")} (${t("status.defaultStatus")})`);
    skipSetting.settingEl.style.cursor = "pointer";
    skipSetting.settingEl.onclick = () => {
      this.selectedStatus = null;
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.onChooseStatus(this.selectedStatus);
  }
};

// Views/suggest_modal.ts
init_i18n();
var toImageInfoArray = (items) => {
  if (!items) return [];
  return items.map((item) => typeof item === "string" ? { url: item } : item);
};
var ItemsSuggestModal = class extends import_obsidian7.SuggestModal {
  constructor(plugin, suggestion, onChoose) {
    super(plugin.app);
    this.plugin = plugin;
    this.suggestion = suggestion;
    this.onChoose = onChoose;
    this.token = "";
    this.token = plugin.settings.apiToken;
    this.TMDBProvider = new TMDBProvider({
      actorsPath: plugin.settings.actorsPath,
      directorsPath: plugin.settings.directorsPath,
      writersPath: plugin.settings.writersPath,
      producersPath: plugin.settings.producersPath
    });
  }
  getSuggestions(query) {
    return this.suggestion.filter((item) => {
      const searchQuery = query == null ? void 0 : query.toLowerCase();
      return item.name.toLowerCase().includes(searchQuery) || item.alternativeName.toLowerCase().includes(searchQuery);
    });
  }
  isValidImageUrl(url) {
    if (!url || url.trim() === "") return false;
    try {
      new URL(url);
      return url.startsWith("http://") || url.startsWith("https://");
    } catch (e) {
      return false;
    }
  }
  createPosterElement(item, container) {
    var _a;
    const posterUrl = (_a = item.poster) == null ? void 0 : _a.url;
    if (this.isValidImageUrl(posterUrl)) {
      const imgElement = container.createEl("img", {
        cls: "TMDB-plugin__suggest-poster"
      });
      imgElement.src = posterUrl;
      imgElement.addEventListener("error", () => {
        const placeholder = container.createEl("div", {
          text: t("modals.posterPlaceholderEmoji"),
          cls: "TMDB-plugin__suggest-poster-placeholder"
        });
        placeholder.title = t("modals.posterTooltipGeoblock");
        imgElement.replaceWith(placeholder);
      });
      return imgElement;
    } else {
      const placeholder = container.createEl("div", {
        text: t("modals.posterPlaceholderEmoji"),
        cls: "TMDB-plugin__suggest-poster-placeholder"
      });
      const reason = !posterUrl ? t("modals.posterTooltipMissing") : posterUrl.trim() === "" ? t("modals.posterTooltipEmptyLink") : t("modals.posterTooltipInvalidLink");
      placeholder.title = reason;
      return placeholder;
    }
  }
  //   renderSuggestion  ItemsSuggestModal
  renderSuggestion(item, el) {
    var _a, _b, _c, _d, _e, _f;
    el.addClass("TMDB-plugin__suggest-item");
    const title = item.name;
    const subtitle = item.type === "person" ? `${item.alternativeName}, \u041F\u043E\u043F\u0443\u043B\u044F\u0440\u043D\u043E\u0441\u0442\u044C: ${Number((_b = (_a = item.rating) == null ? void 0 : _a.tmdb) == null ? void 0 : _b.toFixed(0))}` : `${t("common.type")}: ${item.type}, ${t("ratings.year")}: ${item.year}, TMDB: ${Number((_d = (_c = item.rating) == null ? void 0 : _c.tmdb) == null ? void 0 : _d.toFixed(0))}, IMDB: ${Number((_f = (_e = item.rating) == null ? void 0 : _e.imdb) == null ? void 0 : _f.toFixed(0))}`;
    this.createPosterElement(item, el);
    const textInfo = el.createEl("div", {
      cls: "TMDB-plugin__suggest-text-info"
    });
    textInfo.createEl("div", { text: title });
    textInfo.createEl("small", { text: subtitle });
  }
  onChooseSuggestion(item) {
    this.getItemDetails(item);
  }
  updateStatus(message, persistent = true) {
    this.hideLoadingNotice();
    this.loadingNotice = new import_obsidian7.Notice(message, persistent ? 0 : 3e3);
  }
  hideLoadingNotice() {
    if (this.loadingNotice) {
      this.loadingNotice.hide();
      this.loadingNotice = void 0;
    }
  }
  updateLoadingNotice(message) {
    if (this.loadingNotice) {
      const noticeEl = this.loadingNotice.noticeEl;
      if (noticeEl) {
        noticeEl.textContent = message;
      }
    } else {
      this.updateStatus(message);
    }
  }
  createProgressText(current, total, task) {
    if (total === 0) return task;
    const percentage = Math.round(current / total * 100);
    const progressBar = this.createProgressBar(current, total);
    return `${task}
${progressBar} ${current}/${total} (${percentage}%)`;
  }
  createProgressBar(current, total, length = 20) {
    if (total === 0) return "";
    const filled = Math.round(current / total * length);
    const empty = length - filled;
    return "\u2588".repeat(filled) + "\u2591".repeat(empty);
  }
  validateInput(item) {
    var _a;
    if (!(item == null ? void 0 : item.id) || item.id <= 0) {
      new import_obsidian7.Notice(t("modals.errorMovieData"));
      this.onChoose(new Error(t("modals.errorMovieData")));
      return false;
    }
    if (!((_a = this.token) == null ? void 0 : _a.trim())) {
      new import_obsidian7.Notice(t("modals.needApiToken"));
      this.onChoose(new Error(t("modals.needApiToken")));
      return false;
    }
    return true;
  }
  async fetchMovieData(itemId, type) {
    return await this.TMDBProvider.getMovieById(itemId, this.token, type);
  }
  async processImageApprovals(movieShow, itemId, itemType) {
    this.updateLoadingNotice(t("modals.loadingAlternativeImages"));
    const allImages = await this.TMDBProvider.getAllImages(
      itemId,
      this.token,
      itemType
    );
    this.hideLoadingNotice();
    return new Promise(async (resolve) => {
      const modal = new ImageApprovalModal(
        this.app,
        {
          // FIXED:    
          poster: {
            current: movieShow.posterUrl[0] || "",
            all: toImageInfoArray(allImages.posters)
          },
          cover: {
            current: movieShow.coverUrl[0] || "",
            all: toImageInfoArray(allImages.backdrops)
          },
          logo: {
            current: movieShow.logoUrl[0] || "",
            all: toImageInfoArray(allImages.logos)
          }
        },
        async (finalSelection) => {
          movieShow.posterUrl = finalSelection.poster ? [finalSelection.poster] : [];
          movieShow.coverUrl = finalSelection.cover ? [finalSelection.cover] : [];
          movieShow.logoUrl = finalSelection.logo ? [finalSelection.logo] : [];
          if (itemType === "person") {
            movieShow.status = [""];
            resolve(movieShow);
          } else {
            const statusOptions = [
              t("status.willWatch"),
              t("status.haveWatched"),
              t("status.watching"),
              t("status.dropped")
            ];
            new StatusSelectionModal(this.app, statusOptions, (selectedStatus) => {
              movieShow.status = selectedStatus || t("status.willWatch");
              resolve(movieShow);
            }).open();
          }
        }
      );
      modal.open();
    });
  }
  handleSuccess(movieShow, hadImageProcessing = false) {
    this.hideLoadingNotice();
    if (!hadImageProcessing) {
      new import_obsidian7.Notice(t("modals.movieInfoLoaded"));
    }
    this.onChoose(null, movieShow);
  }
  handleError(error) {
    this.hideLoadingNotice();
    const errorMessage = error instanceof Error ? error.message : t("modals.errorGettingDetails");
    new import_obsidian7.Notice(errorMessage);
    console.error("Error getting movie details:", error);
    this.onChoose(error);
  }
  async getItemDetails(item) {
    if (!this.validateInput(item)) {
      return;
    }
    try {
      this.updateStatus(t("modals.loadingMovieInfo"));
      let movieShow = await this.fetchMovieData(item.id, item.type);
      if (!this.plugin.settings.saveImagesLocally) {
        this.handleSuccess(movieShow, false);
        return;
      }
      movieShow = await this.processImageApprovals(movieShow, item.id, item.type);
      let imageProcessingCompleted = false;
      const imageSettings = {
        saveImagesLocally: true,
        imagesFolder: this.plugin.settings.imagesFolder,
        savePosterImage: this.plugin.settings.savePosterImage && movieShow.posterUrl.length > 0,
        saveCoverImage: this.plugin.settings.saveCoverImage && movieShow.coverUrl.length > 0,
        saveLogoImage: this.plugin.settings.saveLogoImage && movieShow.logoUrl.length > 0
      };
      const anyImageToDownload = imageSettings.savePosterImage || imageSettings.saveCoverImage || imageSettings.saveLogoImage;
      if (!anyImageToDownload) {
        this.handleSuccess(movieShow, false);
        return;
      }
      this.updateLoadingNotice(t("modals.preparingImages"));
      const progressCallback = (current, total, currentTask) => {
        const progressText = this.createProgressText(
          current,
          total,
          currentTask
        );
        this.updateLoadingNotice(progressText);
        if (current === total) {
          imageProcessingCompleted = true;
        }
      };
      const processedMovieShow = await processImages(
        this.plugin.app,
        movieShow,
        this.plugin.settings,
        progressCallback
      );
      if (imageProcessingCompleted) {
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
      this.handleSuccess(processedMovieShow, true);
    } catch (error) {
      this.handleError(error);
    }
  }
  onClose() {
    this.hideLoadingNotice();
    super.onClose();
  }
};

// main.ts
init_provider();
init_i18n();

// Settings/settings.ts
var import_obsidian8 = require("obsidian");
init_i18n();
var DEFAULT_SETTINGS = {
  // API settings
  apiToken: "",
  language: "ru",
  // Image settings
  saveImagesLocally: true,
  imagesFolder: "attachments/TMDB",
  savePosterImage: true,
  saveCoverImage: true,
  saveLogoImage: true,
  actorImageFileNameFormat: "{{id}}",
  // Default format for actor image filenames
  // Movie settings
  movieFileNameFormat: "{{nameForFile}} ({{year}})",
  movieFolder: "Movies",
  movieTemplateFile: "",
  // Series settings
  seriesFileNameFormat: "{{nameForFile}} ({{year}})",
  seriesFolder: "Series",
  seriesTemplateFile: "",
  // Actor settings
  actorFolder: "\u041B\u044E\u0434\u0438/\u0410\u043A\u0442\u0451\u0440\u044B",
  actorTemplateFile: "",
  actorFileNameFormat: "{{id}}",
  // Mobile settings
  coverHeightMultiplier: 1.5,
  // Person path settings
  actorsPath: "\u041B\u044E\u0434\u0438/\u0410\u043A\u0442\u0451\u0440\u044B",
  directorsPath: "\u041B\u044E\u0434\u0438/\u0420\u0435\u0436\u0438\u0441\u0441\u0451\u0440\u044B",
  writersPath: "\u041B\u044E\u0434\u0438/\u0421\u0446\u0435\u043D\u0430\u0440\u0438\u0441\u0442\u044B",
  producersPath: "\u041B\u044E\u0434\u0438/\u041F\u0440\u043E\u0434\u044E\u0441\u0435\u0440\u044B",
  autoFillOnCreate: false
};
var ObsidianTMDBSettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("obsidian-TMDB-plugin__settings");
    new import_obsidian8.Setting(containerEl).setName(t("settings.language")).setDesc(t("settings.languageDesc")).addDropdown(
      (dropdown) => dropdown.addOption("ru", "\u0420\u0443\u0441\u0441\u043A\u0438\u0439").addOption("en", "English").setValue(this.plugin.settings.language).onChange(async (value) => {
        this.plugin.settings.language = value;
        await this.plugin.saveSettings();
        const { initializeLanguage: initializeLanguage2 } = await Promise.resolve().then(() => (init_i18n(), i18n_exports));
        initializeLanguage2(value);
      })
    );
    new import_obsidian8.Setting(containerEl).setName(t("settings.apiToken")).setDesc(
      createFragment((frag) => {
        frag.createDiv({ text: t("settings.apiTokenDesc") });
        frag.createEl("a", {
          text: t("settings.getApiToken"),
          href: "https://www.themoviedb.org/settings/api"
        });
      })
    ).addText(
      (text) => text.setPlaceholder(t("settings.apiTokenPlaceholder")).setValue(this.plugin.settings.apiToken).onChange(async (value) => {
        this.plugin.settings.apiToken = value;
        await this.plugin.saveSettings();
      })
    ).addButton(
      (btn) => btn.setButtonText(t("settings.validateToken")).setCta().onClick(async () => {
        const { validateApiToken: validateApiToken2 } = await Promise.resolve().then(() => (init_provider(), provider_exports));
        const isValid = await validateApiToken2(
          this.plugin.settings.apiToken
        );
        const tokenInput = containerEl.querySelector(
          ".setting-item-control input"
        );
        if (tokenInput) {
          if (isValid) {
            tokenInput.classList.add("TMDB-plugin__token-valid");
            tokenInput.classList.remove("TMDB-plugin__token-invalid");
          } else {
            tokenInput.classList.add("TMDB-plugin__token-invalid");
            tokenInput.classList.remove("TMDB-plugin__token-valid");
          }
        }
      })
    );
    containerEl.createEl("h3", { text: t("settings.imagesHeading") });
    new import_obsidian8.Setting(containerEl).setName(t("settings.saveImagesLocally")).setDesc(t("settings.saveImagesLocallyDesc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.saveImagesLocally).onChange(async (value) => {
        this.plugin.settings.saveImagesLocally = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian8.Setting(containerEl).setName(t("settings.imagesFolder")).setDesc(t("settings.imagesFolderDesc")).addSearch(
      (search) => search.setPlaceholder("attachments/TMDB").setValue(this.plugin.settings.imagesFolder).onChange(async (value) => {
        this.plugin.settings.imagesFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian8.Setting(containerEl).setName(t("settings.savePosterImage")).setDesc(t("settings.savePosterImageDesc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.savePosterImage).onChange(async (value) => {
        this.plugin.settings.savePosterImage = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian8.Setting(containerEl).setName("\u0424\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0430\u043A\u0442\u0451\u0440\u0430").setDesc("\u0414\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0435 \u043F\u0435\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0435: {{id}}, {{nameForFile}}, {{enNameForFile}}").addText(
      (text) => text.setPlaceholder("{{id}}").setValue(this.plugin.settings.actorImageFileNameFormat).onChange(async (value) => {
        this.plugin.settings.actorImageFileNameFormat = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0430\u043A\u0442\u0451\u0440\u043E\u0432" });
    new import_obsidian8.Setting(containerEl).setName("\u0424\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0430\u043A\u0442\u0451\u0440\u0430").setDesc("\u0414\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0435 \u043F\u0435\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0435: {{id}}, {{nameForFile}}, {{enNameForFile}}").addText(
      (text) => text.setPlaceholder("{{id}}").setValue(this.plugin.settings.actorFileNameFormat).onChange(async (value) => {
        this.plugin.settings.actorFileNameFormat = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian8.Setting(containerEl).setName("\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0430\u043A\u0442\u0451\u0440\u043E\u0432").setDesc("\u041F\u0430\u043F\u043A\u0430, \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C\u0441\u044F \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E\u0431 \u0430\u043A\u0442\u0451\u0440\u0430\u0445").addSearch(
      (search) => search.setPlaceholder("\u041B\u044E\u0434\u0438/\u0410\u043A\u0442\u0451\u0440\u044B").setValue(this.plugin.settings.actorFolder).onChange(async (value) => {
        this.plugin.settings.actorFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian8.Setting(containerEl).setName("\u0428\u0430\u0431\u043B\u043E\u043D \u0434\u043B\u044F \u0430\u043A\u0442\u0451\u0440\u043E\u0432").setDesc("\u0424\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430 \u0434\u043B\u044F \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u044F \u0437\u0430\u043C\u0435\u0442\u043E\u043A \u043E\u0431 \u0430\u043A\u0442\u0451\u0440\u0430\u0445").addSearch(
      (search) => search.setPlaceholder("Templates/actor.md").setValue(this.plugin.settings.actorTemplateFile).onChange(async (value) => {
        this.plugin.settings.actorTemplateFile = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Auto-fill on create").setDesc("Automatically search TMDB when a new file is created in movie/series/actor folders").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoFillOnCreate).onChange(async (value) => {
        this.plugin.settings.autoFillOnCreate = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// main.ts
init_utils();

// Utils/cursor_jumper.ts
var import_obsidian9 = require("obsidian");
var CursorJumper = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Move cursor to the beginning of active document
   */
  async jumpToNextCursorLocation() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
      if (!(activeView == null ? void 0 : activeView.file)) {
        return;
      }
      const editor = activeView.editor;
      if (!editor) {
        return;
      }
      editor.focus();
      editor.setCursor(0, 0);
    } catch (error) {
      console.error("Error moving cursor:", error);
    }
  }
};

// main.ts
init_i18n();
var ObsidianTMDBPlugin = class extends import_obsidian10.Plugin {
  async onload() {
    await this.loadSettings();
    initializeLanguage(this.settings.language);
    this.addRibbonIcon("user", "Search actors in TMDB", () => {
      this.createNewNote();
    });
    this.addCommand({
      id: "search",
      name: "Search",
      callback: () => {
        this.createNewNote();
      }
    });
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian10.TFile) {
          this.onFileCreated(file);
        }
      })
    );
    this.addSettingTab(new ObsidianTMDBSettingTab(this.app, this));
    this.setupFileDeletionListener();
    this.setupFileCreationListener();
  }
  // Setup file creation listener to handle new file events
  setupFileCreationListener() {
    this.registerEvent(
      this.app.vault.on("create", async (file) => {
        if (file instanceof import_obsidian10.TFile) {
          await this.handleFileCreation(file);
        }
      })
    );
  }
  // Handle file creation event
  async handleFileCreation(file) {
    console.log(`[FileCreation] New file created: ${file.path}`);
  }
  // Setup file deletion listener to automatically remove associated media files
  setupFileDeletionListener() {
    this.registerEvent(
      this.app.vault.on("delete", async (file) => {
        if (file instanceof import_obsidian10.TFile) {
          await this.handleFileDeletion(file);
        }
      })
    );
  }
  // Handle file deletion by removing associated media files
  async handleFileDeletion(file) {
    const movieFolderPath = this.settings.movieFolder;
    const seriesFolderPath = this.settings.seriesFolder;
    const isInMovieFolder = movieFolderPath && file.path.startsWith(movieFolderPath);
    const isInSeriesFolder = seriesFolderPath && file.path.startsWith(seriesFolderPath);
    if (!isInMovieFolder && !isInSeriesFolder) {
      return;
    }
    const fileNameWithoutExt = file.basename;
    if (!fileNameWithoutExt) {
      return;
    }
    console.log(`[FileDeletion] Detected deletion of: ${file.path}, looking for associated media files...`);
    const filesToDelete = [];
    const allFiles = this.app.vault.getFiles();
    const searchPattern = new RegExp(`^${this.escapeRegExp(fileNameWithoutExt)}(?:_|-|\\.\\w|$)`, "i");
    for (const vaultFile of allFiles) {
      if ((vaultFile.extension === "jpg" || vaultFile.extension === "jpeg" || vaultFile.extension === "png" || vaultFile.extension === "gif" || vaultFile.extension === "webp") && // Match files that start with the note name or contain it in a meaningful way
      (vaultFile.name.toLowerCase().startsWith(fileNameWithoutExt.toLowerCase()) || vaultFile.name.toLowerCase().includes(fileNameWithoutExt.toLowerCase() + "_") || vaultFile.name.toLowerCase().includes(fileNameWithoutExt.toLowerCase() + "-") || searchPattern.test(vaultFile.name))) {
        filesToDelete.push(vaultFile);
      }
    }
    for (const mediaFile of filesToDelete) {
      try {
        await this.app.vault.delete(mediaFile);
        console.log(`[FileDeletion] Deleted associated media file: ${mediaFile.path}`);
      } catch (error) {
        console.error(`[FileDeletion] Error deleting media file ${mediaFile.path}:`, error);
      }
    }
    if (filesToDelete.length > 0) {
      new import_obsidian10.Notice(`Deleted ${filesToDelete.length} associated media file(s) for: ${fileNameWithoutExt}`);
    }
  }
  // Helper function to escape special regex characters
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  // Shows error notification to user
  showNotice(error) {
    try {
      new import_obsidian10.Notice(error.message);
    } catch (e) {
    }
  }
  //   createNewNote()    
  async createNewNote() {
    try {
      console.log("[Main] Starting createNewNote");
      const movieShow = await this.searchMovieShow();
      console.log("[Main] Movie/Show/Person received:", {
        id: movieShow.id,
        name: movieShow.name,
        type: movieShow.type,
        isSeries: movieShow.isSeries,
        year: movieShow.year
      });
      const {
        movieFileNameFormat,
        movieFolder,
        seriesFileNameFormat,
        seriesFolder,
        actorFolder,
        //   
        actorFileNameFormat
        //     
      } = this.settings;
      let fileNameFormat;
      let folderPath;
      const itemType = Array.isArray(movieShow.type) ? movieShow.type[0] : movieShow.type;
      console.log("[Main] Item type detected:", itemType);
      if (itemType === "person" || itemType === "\u041F\u0435\u0440\u0441\u043E\u043D\u0430" || itemType.toLowerCase().includes("person")) {
        fileNameFormat = actorFileNameFormat || "{{id}}";
        folderPath = actorFolder || movieFolder;
        console.log("[Main] Using actor settings:", { fileNameFormat, folderPath });
      } else if (movieShow.isSeries) {
        fileNameFormat = seriesFileNameFormat;
        folderPath = seriesFolder;
        console.log("[Main] Using series settings");
      } else {
        fileNameFormat = movieFileNameFormat;
        folderPath = movieFolder;
        console.log("[Main] Using movie settings");
      }
      const status = movieShow.status || t("status.willWatch");
      movieShow.status = [status];
      const finalContents = await this.getRenderedContents(movieShow);
      if (folderPath && !await this.app.vault.adapter.exists(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      const fileName = await makeFileName(
        this.app,
        movieShow,
        fileNameFormat,
        folderPath
      );
      console.log("[Main] Creating file with name:", fileName);
      const filePath = `${folderPath}/${fileName}`;
      const targetFile = await this.app.vault.create(
        filePath,
        finalContents
      );
      const newLeaf = this.app.workspace.getLeaf(true);
      if (!newLeaf) {
        console.warn("No new leaf");
        return;
      }
      await newLeaf.openFile(targetFile, { state: { mode: "preview" } });
      newLeaf.setEphemeralState({ rename: "all" });
      await new CursorJumper(this.app).jumpToNextCursorLocation();
    } catch (err) {
      console.warn(err);
      this.showNotice(err);
    }
  }
  // Add status to content
  addStatusToContent(content, status) {
    const escapedStatus = status.replace(/"/g, '\\"');
    let processedContent = content.replace(/{{status}}/gi, escapedStatus);
    if (processedContent.startsWith("---")) {
      const frontmatterEndIndex = processedContent.indexOf("\n---\n", 3);
      if (frontmatterEndIndex !== -1) {
        const frontmatter = processedContent.substring(0, frontmatterEndIndex + 5);
        const body = processedContent.substring(frontmatterEndIndex + 5);
        const statusPattern = new RegExp(`${t("common.status")}:\\s*["']?([^"'
,}]+)["']?`, "i");
        if (frontmatter.match(statusPattern)) {
          const updatedFrontmatter = frontmatter.replace(statusPattern, `${t("common.status")}: "${escapedStatus}"`);
          return `${updatedFrontmatter}${body}`;
        } else {
          const updatedFrontmatter = frontmatter.replace("\n---\n", `
${t("common.status")}: "${escapedStatus}"
---
`);
          return `${updatedFrontmatter}${body}`;
        }
      } else {
        const altFrontmatterEndIndex = processedContent.indexOf("---\n", 4);
        if (altFrontmatterEndIndex !== -1) {
          const frontmatter = processedContent.substring(0, altFrontmatterEndIndex + 4);
          const body = processedContent.substring(altFrontmatterEndIndex + 4);
          const statusPattern = new RegExp(`${t("common.status")}:\\s*["']?([^"'
,}]+)["']?`, "i");
          if (frontmatter.match(statusPattern)) {
            const updatedFrontmatter = frontmatter.replace(statusPattern, `${t("common.status")}: "${escapedStatus}"`);
            return `${updatedFrontmatter}${body}`;
          } else {
            const updatedFrontmatter = frontmatter.replace("---\n", `---
${t("common.status")}: "${escapedStatus}"
`);
            return `${updatedFrontmatter}${body}`;
          }
        }
      }
    }
    return processedContent;
  }
  // Coordinates search process: search then select from results
  async searchMovieShow() {
    const searchedItems = await this.openSearchModal();
    return await this.openSuggestModal(searchedItems);
  }
  // Opens search modal and returns found items
  async openSearchModal() {
    return new Promise((resolve, reject) => {
      return new SearchModal(this, (error, results) => {
        return error ? reject(error) : resolve(results != null ? results : []);
      }).open();
    });
  }
  // Opens suggestion modal and returns detailed info about selected item
  async openSuggestModal(items) {
    return new Promise((resolve, reject) => {
      return new ItemsSuggestModal(this, items, (error, selectedItem) => {
        return error ? reject(error) : resolve(selectedItem);
      }).open();
    });
  }
  async getRenderedContents(movieShow) {
    const {
      movieTemplateFile,
      seriesTemplateFile,
      actorTemplateFile
      //   
    } = this.settings;
    const itemType = Array.isArray(movieShow.type) ? movieShow.type[0] : movieShow.type;
    let templateFile;
    if (itemType === "person") {
      templateFile = actorTemplateFile || movieTemplateFile;
    } else {
      templateFile = movieShow.isSeries ? seriesTemplateFile : movieTemplateFile;
    }
    if (templateFile) {
      const templateContents = await getTemplateContents(
        this.app,
        templateFile
      );
      const replacedVariable = replaceVariableSyntax(
        movieShow,
        templateContents
      );
      return replacedVariable;
    }
    return "";
  }
  // Analyzes all notes in configured folders for those with "_res" in poster filename or ""
  // Extracts title and rating, searches TMDB, and creates new notes with user rating - runs in background
  async analyzeAllResNotes() {
    try {
      console.log("[AnalyzeAll] Starting analysis of all _res notes in configured folders");
      const movieFolderPath = this.settings.movieFolder;
      const seriesFolderPath = this.settings.seriesFolder;
      const movieFiles = movieFolderPath ? await this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(movieFolderPath)) : [];
      const seriesFiles = seriesFolderPath && seriesFolderPath !== movieFolderPath ? await this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(seriesFolderPath)) : [];
      const allFiles = [.../* @__PURE__ */ new Set([...movieFiles, ...seriesFiles])];
      console.log(`[AnalyzeAll] Found ${allFiles.length} markdown files in configured folders`);
      if (allFiles.length === 0) {
        new import_obsidian10.Notice("No files found in configured folders.");
        return;
      }
      const progressNotice = new import_obsidian10.Notice(`Analyzing 0/${allFiles.length} files...`, 0);
      let processedCount = 0;
      let errorCount = 0;
      for (const file of allFiles) {
        try {
          const content = await this.app.vault.cachedRead(file);
          if (this.containsResPoster(content)) {
            console.log(`[AnalyzeAll] Found _res poster in file: ${file.path}`);
            await this.processResNoteInBackground(file, content);
            processedCount++;
          }
          progressNotice.setMessage(`Analyzing ${processedCount + errorCount}/${allFiles.length} files...`);
        } catch (error) {
          console.error(`[AnalyzeAll] Error processing file ${file.path}:`, error);
          errorCount++;
          progressNotice.setMessage(`Analyzing ${processedCount + errorCount}/${allFiles.length} files... (${errorCount} errors)`);
        }
      }
      progressNotice.hide();
      new import_obsidian10.Notice(`Mass analysis completed! Processed: ${processedCount}, Errors: ${errorCount}`);
      console.log(`[AnalyzeAll] Mass analysis completed! Processed: ${processedCount}, Errors: ${errorCount}`);
    } catch (err) {
      console.warn(err);
      this.showNotice(err);
    }
  }
  // Process a note in background without opening it
  async processResNoteInBackground(file, content) {
    console.log(`[ProcessBg] Processing file in background: ${file.path}`);
    const title = this.extractTitle(file.basename, content);
    const rating = this.extractRating(content);
    const hasUserRating = new RegExp(`${t("ratings.myRating")}:\\s*\\d+\\.?\\d*`, "i").test(content);
    const customStatus = this.extractCustomStatus(content);
    const yearFromFile = this.extractYearFromFile(file.basename);
    const yearFromContent = this.extractYear(content);
    const year = yearFromFile || yearFromContent;
    console.log(`[ProcessBg] Extracted title: ${title}, rating: ${rating}, hasUserRating: ${hasUserRating}, status: ${customStatus}, year: ${year}`);
    if (title) {
      const searchResults = await this.searchOnTMDB(title);
      if (searchResults && searchResults.length > 0) {
        const bestMatch = this.findBestMatch(searchResults, title, year);
        if (bestMatch) {
          console.log(`[ProcessBg] Best match found: ${bestMatch.name}`);
          await this.createNoteWithRatingInBackground(file, bestMatch, rating, customStatus, hasUserRating);
        }
      }
    }
  }
  // Create a new note in background without opening it
  async createNoteWithRatingInBackground(originalFile, item, userRating, customStatus = null, hasUserRating = false) {
    if (!item || !this.settings.apiToken) {
      return;
    }
    try {
      const originalPath = originalFile.path;
      const lastSlashIndex = originalPath.lastIndexOf("/");
      const lastSlashIndexWin = originalPath.lastIndexOf("\\");
      const lastSlashPos = Math.max(lastSlashIndex, lastSlashIndexWin);
      const folderPath = originalPath.substring(0, lastSlashPos + 1);
      const fileNameWithExt = originalPath.substring(lastSlashPos + 1);
      const lastDotIndex = fileNameWithExt.lastIndexOf(".");
      const baseName = fileNameWithExt.substring(0, lastDotIndex);
      const extension = fileNameWithExt.substring(lastDotIndex + 1);
      const newPath = folderPath + baseName + "_old." + extension;
      await this.app.fileManager.renameFile(originalFile, newPath);
      console.log(`[RenameBg] Renamed original file to: ${newPath}`);
      const provider2 = new TMDBProvider();
      let movieShow = await provider2.getMovieById(item.id, this.settings.apiToken, item.type, userRating != null ? userRating : void 0);
      if (this.settings.saveImagesLocally) {
        const { processImages: processImages2 } = await Promise.resolve().then(() => (init_imageUtils(), imageUtils_exports));
        movieShow = await processImages2(
          this.app,
          movieShow,
          this.settings
        );
      }
      if (userRating !== null) {
        movieShow.userRating = userRating;
      }
      if (customStatus) {
        movieShow.status = [customStatus];
      } else {
        movieShow.status = [t("status.willWatch")];
      }
      const targetFolderPath = item.type === "tv-series" ? this.settings.seriesFolder : this.settings.movieFolder;
      if (targetFolderPath && !await this.app.vault.adapter.exists(targetFolderPath)) {
        await this.app.vault.createFolder(targetFolderPath);
      }
      let renderedContents = await this.getRenderedContents(movieShow);
      if (customStatus !== null) {
        const escapedStatus = customStatus.replace(/"/g, '\\"');
        renderedContents = renderedContents.replace(new RegExp(`${t("common.status")}:\\s*["']?([^"'
,}]+)["']?`, "i"), `${t("common.status")}: "${escapedStatus}"`);
      }
      if (userRating !== null && hasUserRating) {
        if (!renderedContents.includes("{{userRating}}")) {
          if (renderedContents.startsWith("---")) {
            const frontmatterEndIndex = renderedContents.indexOf("\n---\n", 3);
            if (frontmatterEndIndex !== -1) {
              const frontmatter = renderedContents.substring(0, frontmatterEndIndex + 5);
              const body = renderedContents.substring(frontmatterEndIndex + 5);
              if (!frontmatter.includes(`${t("ratings.myRating")}:`)) {
                const updatedFrontmatter = frontmatter.replace("\n---\n", `
${t("ratings.myRating")}: ${userRating}
---
`);
                renderedContents = `${updatedFrontmatter}${body}`;
              }
            } else {
              const altFrontmatterEndIndex = renderedContents.indexOf("---\n", 4);
              if (altFrontmatterEndIndex !== -1) {
                const frontmatter = renderedContents.substring(0, altFrontmatterEndIndex + 4);
                const body = renderedContents.substring(altFrontmatterEndIndex + 4);
                if (!frontmatter.includes(`${t("ratings.myRating")}:`)) {
                  const updatedFrontmatter = frontmatter.replace("---\n", `${t("ratings.myRating")}: ${userRating}
---
`);
                  renderedContents = `${updatedFrontmatter}${body}`;
                }
              } else {
                renderedContents = renderedContents.replace("---", `---
${t("ratings.myRating")}: ${userRating}`);
              }
            }
          } else {
            renderedContents = `---
${t("ratings.myRating")}: ${userRating}
---

${renderedContents}`;
          }
        }
      }
      const originalFileName = baseName.replace("_old", "") + "." + extension;
      const newFilePath = `${targetFolderPath}/${originalFileName}`;
      const targetFile = await this.app.vault.create(
        newFilePath,
        renderedContents
      );
      console.log(`[CreateBg] Created updated note with user rating: ${newFilePath}`);
    } catch (error) {
      console.error("[Update NoteBg] Error updating note with rating:", error);
      this.showNotice(new Error(`Error updating note: ${error.message}`));
    }
  }
  // Analyzes the current active note for "_res" in poster filename
  // Extracts title and rating, searches TMDB, and creates new notes with user rating
  async analyzeResNotes() {
    try {
      console.log("[Analyze] Starting analysis of current note for _res poster");
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile || activeFile.extension !== "md") {
        new import_obsidian10.Notice("Please open a markdown note to analyze");
        return;
      }
      const content = await this.app.vault.cachedRead(activeFile);
      console.log(`[Analyze] Analyzing current file: ${activeFile.path}`);
      if (this.containsResPoster(content)) {
        console.log(`[Analyze] Found _res poster in current file`);
        await this.processResNote(activeFile, content);
        new import_obsidian10.Notice(`Found and processed _res note: ${activeFile.basename}`);
      } else {
        new import_obsidian10.Notice(`Current note does not contain _res poster: ${activeFile.basename}`);
        console.log(`[Analyze] Current file does not contain _res poster`);
      }
    } catch (err) {
      console.warn(err);
      this.showNotice(err);
    }
  }
  // Check if content contains "_res" in poster filename or ""
  containsResPoster(content) {
    const resPattern = /(!\[\[.*_res|!\[.*\]\(.*_res|poster.*_res|cover.*_res|_resources)/i;
    const kinopoiskPattern = new RegExp(`${t("ratings.kinopoiskRating")}:\\s*\\d+\\.?\\d*`, "i");
    return resPattern.test(content) || kinopoiskPattern.test(content);
  }
  // Process a note that contains "_res" in poster filename
  async processResNote(file, content) {
    console.log(`[Process] Processing file: ${file.path}`);
    const title = this.extractTitle(file.basename, content);
    const rating = this.extractRating(content);
    const hasUserRating = new RegExp(`${t("ratings.myRating")}:\\s*\\d+\\.?\\d*`, "i").test(content);
    const customStatus = this.extractCustomStatus(content);
    const yearFromFile = this.extractYearFromFile(file.basename);
    const yearFromContent = this.extractYear(content);
    const year = yearFromFile || yearFromContent;
    console.log(`[Process] Extracted title: ${title}, rating: ${rating}, hasUserRating: ${hasUserRating}, status: ${customStatus}, year: ${year}`);
    if (title) {
      const searchResults = await this.searchOnTMDB(title);
      if (searchResults && searchResults.length > 0) {
        const bestMatch = this.findBestMatch(searchResults, title, year);
        if (bestMatch) {
          console.log(`[Process] Best match found: ${bestMatch.name}`);
          await this.createNoteWithRating(bestMatch, rating, customStatus, hasUserRating);
        }
      }
    }
  }
  // Extract title from filename or content
  extractTitle(basename, content) {
    const filenameTitle = basename.replace(/\s*\(\d{4}\).*/, "").trim();
    if (filenameTitle) return filenameTitle;
    const titleMatch = content.match(/title:\s*["']?([^"'\n]+)/i);
    if (titleMatch) return titleMatch[1].trim();
    const nameMatch = content.match(/name:\s*["']?([^"'\n]+)/i);
    if (nameMatch) return nameMatch[1].trim();
    return "";
  }
  // Extract year from filename or content
  extractYearFromFile(basename) {
    const yearMatch = basename.match(/\((\d{4})\)/);
    if (yearMatch && yearMatch[1]) {
      return parseInt(yearMatch[1]);
    }
    return null;
  }
  // Extract rating from content - prioritize user rating over Kinopoisk rating
  extractRating(content) {
    const userRatingPatterns = [
      new RegExp(`${t("ratings.myRating")}:\\s*(\\d+\\.?\\d*)`, "i"),
      // Localized "MyRating" - highest priority
      /rating:\s*(\d+\.?\d*)/i,
      /user_rating:\s*(\d+\.?\d*)/i,
      /my_rating:\s*(\d+\.?\d*)/i,
      /:\s*(\d+\.?\d*)/i,
      // Russian for "rating"
      /:\s*(\d+\.?\d*)/i
      // Russian for "rating"
    ];
    for (const pattern of userRatingPatterns) {
      const match = content.match(pattern);
      if (match && match[1]) {
        const rating = parseFloat(match[1]);
        if (!isNaN(rating)) {
          return rating;
        }
      }
    }
    const kinopoiskPattern = new RegExp(`${t("ratings.kinopoiskRating")}:\\s*(\\d+\\.?\\d*)`, "i");
    const kinopoiskMatch = content.match(kinopoiskPattern);
    if (kinopoiskMatch && kinopoiskMatch[1]) {
      const rating = parseFloat(kinopoiskMatch[1]);
      if (!isNaN(rating)) {
        return rating;
      }
    }
    return null;
  }
  // Extract custom status from content
  extractCustomStatus(content) {
    const statusPatterns = [
      new RegExp(`${t("common.status")}:\\s*["']?([^"'
,]+)`, "i"),
      // Localized "Status"
      /status:\s*["']?([^"'\n,]+)/i
    ];
    for (const pattern of statusPatterns) {
      const match = content.match(pattern);
      if (match && match[1]) {
        return match[1].trim();
      }
    }
    return null;
  }
  // Extract Kinopoisk rating from content
  extractKinopoiskRating(content) {
    const kinopoiskPattern = new RegExp(`${t("ratings.kinopoiskRating")}:\\s*(\\d+\\.?\\d*)`, "i");
    const match = content.match(kinopoiskPattern);
    if (match && match[1]) {
      const rating = parseFloat(match[1]);
      if (!isNaN(rating)) {
        return rating;
      }
    }
    return null;
  }
  // Extract year from content
  extractYear(content) {
    const yearPatterns = [
      new RegExp(`${t("ratings.year")}:\\s*(\\d{4})`, "i"),
      // Localized "Year"
      /year:\s*(\d{4})/i,
      /release_date.*?(\d{4})/i,
      /\b(19|20)\d{2}\b/
      // More specific 4-digit year pattern (19xx-20xx)
    ];
    for (const pattern of yearPatterns) {
      const match = content.match(pattern);
      if (match && match[0] && /^\d{4}$/.test(match[0])) {
        return parseInt(match[0]);
      }
    }
    return null;
  }
  // Search TMDB for a title
  async searchOnTMDB(title) {
    if (!title || !this.settings.apiToken) {
      return null;
    }
    try {
      const provider2 = new TMDBProvider();
      return await provider2.searchByQuery(title, this.settings.apiToken);
    } catch (error) {
      console.error(`[TMDB Search] Error searching for "${title}":`, error);
      return null;
    }
  }
  // Find the best matching result based on title and year
  findBestMatch(results, title, year) {
    if (!results || results.length === 0) {
      return null;
    }
    const exactTitleMatches = results.filter(
      (item) => item.name.toLowerCase() === title.toLowerCase() || item.alternativeName.toLowerCase() === title.toLowerCase()
    );
    if (exactTitleMatches.length > 0) {
      if (year) {
        const exactMatchWithYear = exactTitleMatches.find((item) => item.year === year);
        if (exactMatchWithYear) return exactMatchWithYear;
        const closeYearMatch = exactTitleMatches.find(
          (item) => item.year > 0 && Math.abs(item.year - year) <= 1
        );
        if (closeYearMatch) return closeYearMatch;
      }
      return exactTitleMatches[0];
    }
    const fuzzyMatches = results.filter(
      (item) => item.name.toLowerCase().includes(title.toLowerCase()) || item.alternativeName.toLowerCase().includes(title.toLowerCase())
    );
    if (fuzzyMatches.length > 0) {
      if (year) {
        const fuzzyMatchWithYear = fuzzyMatches.find((item) => item.year === year);
        if (fuzzyMatchWithYear) return fuzzyMatchWithYear;
        const closeFuzzyYearMatch = fuzzyMatches.find(
          (item) => item.year > 0 && Math.abs(item.year - year) <= 1
        );
        if (closeFuzzyYearMatch) return closeFuzzyYearMatch;
      }
      return fuzzyMatches[0];
    }
    return results[0];
  }
  async onFileCreated(file) {
    if (!this.settings.autoFillOnCreate || file.extension !== "md") {
      return;
    }
    const movieFolder = this.settings.movieFolder;
    const seriesFolder = this.settings.seriesFolder;
    const actorFolder = this.settings.actorFolder;
    const isInAllowedFolder = movieFolder && file.path.startsWith(movieFolder) || seriesFolder && file.path.startsWith(seriesFolder) || actorFolder && file.path.startsWith(actorFolder);
    if (!isInAllowedFolder) return;
    const content = await this.app.vault.read(file);
    if (content.trim().length > 10) return;
    const searchQuery = file.basename;
    setTimeout(async () => {
      try {
        const isNumericId = /^\d+$/.test(searchQuery.trim());
        let selectedMovie;
        const provider2 = new TMDBProvider();
        if (isNumericId) {
          const id = parseInt(searchQuery.trim());
          new import_obsidian10.Notice(`Fetching from TMDB by ID: ${id}`);
          selectedMovie = await provider2.getMovieById(id, this.settings.apiToken, "movie");
        } else {
          new import_obsidian10.Notice(`Searching TMDB for: ${searchQuery}`);
          const searchResults = await provider2.searchByQuery(searchQuery, this.settings.apiToken);
          if (!(searchResults == null ? void 0 : searchResults.length)) {
            new import_obsidian10.Notice(`No results found for "${searchQuery}"`);
            return;
          }
          selectedMovie = await this.openSuggestModal(searchResults);
        }
        if (this.settings.saveImagesLocally) {
          new import_obsidian10.Notice("Processing images...");
          const { processImages: processImages2 } = await Promise.resolve().then(() => (init_imageUtils(), imageUtils_exports));
          selectedMovie = await processImages2(this.app, selectedMovie, this.settings);
        }
        const renderedContents = await this.getRenderedContents(selectedMovie);
        await this.app.vault.modify(file, renderedContents);
        const leaf = this.app.workspace.getLeaf(false);
        await leaf.openFile(file, { state: { mode: "preview" } });
        new import_obsidian10.Notice("Data auto-filled successfully!");
      } catch (err) {
        console.warn("Error auto-filling file:", err);
      }
    }, 300);
  }
  // Update the original note with TMDB data and user rating
  async createNoteWithRating(item, userRating, customStatus = null, hasUserRating = false) {
    if (!item || !this.settings.apiToken) {
      return;
    }
    try {
      const updateNotice = new import_obsidian10.Notice(`Updating: ${item.name}`, 0);
      const originalFile = this.app.workspace.getActiveFile();
      if (!originalFile) {
        console.error("[Update Note] No active file found");
        updateNotice.hide();
        return;
      }
      const originalContent = await this.app.vault.read(originalFile);
      const originalPath = originalFile.path;
      const lastSlashIndex = originalPath.lastIndexOf("/");
      const lastSlashIndexWin = originalPath.lastIndexOf("\\");
      const lastSlashPos = Math.max(lastSlashIndex, lastSlashIndexWin);
      const folderPath = originalPath.substring(0, lastSlashPos + 1);
      const fileNameWithExt = originalPath.substring(lastSlashPos + 1);
      const lastDotIndex = fileNameWithExt.lastIndexOf(".");
      const baseName = fileNameWithExt.substring(0, lastDotIndex);
      const extension = fileNameWithExt.substring(lastDotIndex + 1);
      const newPath = folderPath + baseName + "_old." + extension;
      await this.app.fileManager.renameFile(originalFile, newPath);
      console.log(`[Rename] Renamed original file to: ${newPath}`);
      updateNotice.setMessage(`Renamed to: ${baseName}_old.${extension}`);
      const provider2 = new TMDBProvider();
      let movieShow = await provider2.getMovieById(item.id, this.settings.apiToken, item.type, userRating != null ? userRating : void 0);
      updateNotice.setMessage(`Retrieved TMDB data for: ${item.name}`);
      if (this.settings.saveImagesLocally) {
        const { processImages: processImages2 } = await Promise.resolve().then(() => (init_imageUtils(), imageUtils_exports));
        const imageNotice = new import_obsidian10.Notice("Processing images...", 0);
        movieShow = await processImages2(
          this.app,
          movieShow,
          this.settings,
          (current, total, currentTask) => {
            if (total > 0) {
              imageNotice.setMessage(`Images: ${current}/${total}`);
            } else {
              imageNotice.setMessage(currentTask);
            }
          }
        );
        imageNotice.hide();
        new import_obsidian10.Notice("Images processed!");
      }
      if (userRating !== null) {
        movieShow.userRating = userRating;
      }
      if (customStatus) {
        movieShow.status = [customStatus];
      } else {
        movieShow.status = [t("status.willWatch")];
      }
      const itemTypeStr = Array.isArray(movieShow.type) ? movieShow.type[0] : movieShow.type;
      let targetFolderPath;
      if (itemTypeStr === "person" || itemTypeStr === "\u041F\u0435\u0440\u0441\u043E\u043D\u0430") {
        targetFolderPath = this.settings.actorFolder;
      } else if (item.type === "tv-series") {
        targetFolderPath = this.settings.seriesFolder;
      } else {
        targetFolderPath = this.settings.movieFolder;
      }
      if (targetFolderPath && !await this.app.vault.adapter.exists(targetFolderPath)) {
        await this.app.vault.createFolder(targetFolderPath);
      }
      if (targetFolderPath && !await this.app.vault.adapter.exists(targetFolderPath)) {
        await this.app.vault.createFolder(targetFolderPath);
      }
      let renderedContents = await this.getRenderedContents(movieShow);
      updateNotice.setMessage(`Rendering template...`);
      if (userRating !== null && hasUserRating) {
        if (!renderedContents.includes("{{userRating}}")) {
          if (renderedContents.startsWith("---")) {
            const frontmatterEndIndex = renderedContents.indexOf("\n---\n", 3);
            if (frontmatterEndIndex !== -1) {
              const frontmatter = renderedContents.substring(0, frontmatterEndIndex + 5);
              const body = renderedContents.substring(frontmatterEndIndex + 5);
              if (!frontmatter.includes(`${t("ratings.myRating")}:`)) {
                const updatedFrontmatter = frontmatter.replace("\n---\n", `
${t("ratings.myRating")}: ${userRating}
---
`);
                renderedContents = `${updatedFrontmatter}${body}`;
              }
            } else {
              const altFrontmatterEndIndex = renderedContents.indexOf("---\n", 4);
              if (altFrontmatterEndIndex !== -1) {
                const frontmatter = renderedContents.substring(0, altFrontmatterEndIndex + 4);
                const body = renderedContents.substring(altFrontmatterEndIndex + 4);
                if (!frontmatter.includes(`${t("ratings.myRating")}:`)) {
                  const updatedFrontmatter = frontmatter.replace("---\n", `${t("ratings.myRating")}: ${userRating}
---
`);
                  renderedContents = `${updatedFrontmatter}${body}`;
                }
              } else {
                renderedContents = renderedContents.replace("---", `---
${t("ratings.myRating")}: ${userRating}`);
              }
            }
          } else {
            renderedContents = `---
${t("ratings.myRating")}: ${userRating}
---

${renderedContents}`;
          }
        }
      }
      if (customStatus !== null) {
        const escapedStatus = customStatus.replace(/"/g, '\\"');
        renderedContents = renderedContents.replace(new RegExp(`${t("common.status")}:\\s*["']?([^"'
,}]+)["']?`, "i"), `${t("common.status")}: "${escapedStatus}"`);
      }
      const originalFileName = baseName.replace("_old", "") + "." + extension;
      const newFilePath = `${targetFolderPath}/${originalFileName}`;
      const targetFile = await this.app.vault.create(
        newFilePath,
        renderedContents
      );
      console.log(`[Create] Created updated note with user rating: ${newFilePath}`);
      updateNotice.setMessage(`Creating note...`);
      const newLeaf = this.app.workspace.getLeaf(true);
      if (newLeaf) {
        await newLeaf.openFile(targetFile, { state: { mode: "preview" } });
        updateNotice.setMessage(`Opening: ${originalFileName}`);
      }
      updateNotice.hide();
      new import_obsidian10.Notice(`\u2705 Updated: ${originalFileName}`);
    } catch (error) {
      console.error("[Update Note] Error updating note with rating:", error);
      this.showNotice(new Error(`Error updating note: ${error.message}`));
    }
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
